# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-27 02:24-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.3\n"

#: ../../library/ast.rst:2
msgid ":mod:`ast` --- Abstract Syntax Trees"
msgstr ""

#: ../../library/ast.rst:10
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr ""

#: ../../library/ast.rst:14
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""

#: ../../library/ast.rst:19
msgid ""
"An abstract syntax tree can be generated by passing "
":data:`ast.PyCF_ONLY_AST` as a flag to the :func:`compile` built-in "
"function, or using the :func:`parse` helper provided in this module.  The"
" result will be a tree of objects whose classes all inherit from "
":class:`ast.AST`.  An abstract syntax tree can be compiled into a Python "
"code object using the built-in :func:`compile` function."
msgstr ""

#: ../../library/ast.rst:27
msgid "Node classes"
msgstr ""

#: ../../library/ast.rst:31
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced "
":ref:`below <abstract-grammar>`.  They are defined in the :mod:`_ast` C "
"module and re-exported in :mod:`ast`."
msgstr ""

#: ../../library/ast.rst:36
msgid ""
"There is one class defined for each left-hand side symbol in the abstract"
" grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In "
"addition, there is one class defined for each constructor on the right-"
"hand side; these classes inherit from the classes for the left-hand side "
"trees.  For example, :class:`ast.BinOp` inherits from :class:`ast.expr`."
"  For production rules with alternatives (aka \"sums\"), the left-hand "
"side class is abstract: only instances of specific constructor nodes are "
"ever created."
msgstr ""

#: ../../library/ast.rst:46
msgid ""
"Each concrete class has an attribute :attr:`_fields` which gives the "
"names of all child nodes."
msgstr ""

#: ../../library/ast.rst:49
msgid ""
"Each instance of a concrete class has one attribute for each child node, "
"of the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""

#: ../../library/ast.rst:53
msgid ""
"If these attributes are marked as optional in the grammar (using a "
"question mark), the value might be ``None``.  If the attributes can have "
"zero-or-more values (marked with an asterisk), the values are represented"
" as Python lists.  All possible attributes must be present and have valid"
" values when compiling an AST with :func:`compile`."
msgstr ""

#: ../../library/ast.rst:62
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have "
":attr:`lineno` and :attr:`col_offset` attributes.  The :attr:`lineno` is "
"the line number of source text (1-indexed so the first line is line 1) "
"and the :attr:`col_offset` is the UTF-8 byte offset of the first token "
"that generated the node.  The UTF-8 offset is recorded because the parser"
" uses UTF-8 internally."
msgstr ""

#: ../../library/ast.rst:69
msgid "The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr ""

#: ../../library/ast.rst:71
msgid ""
"If there are positional arguments, there must be as many as there are "
"items in :attr:`T._fields`; they will be assigned as attributes of these "
"names."
msgstr ""

#: ../../library/ast.rst:73
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr ""

#: ../../library/ast.rst:76
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you "
"could use ::"
msgstr ""

#: ../../library/ast.rst:79
msgid ""
"node = ast.UnaryOp()\n"
"node.op = ast.USub()\n"
"node.operand = ast.Num()\n"
"node.operand.n = 5\n"
"node.operand.lineno = 0\n"
"node.operand.col_offset = 0\n"
"node.lineno = 0\n"
"node.col_offset = 0"
msgstr ""

#: ../../library/ast.rst:88
msgid "or the more compact ::"
msgstr ""

#: ../../library/ast.rst:90
msgid ""
"node = ast.UnaryOp(ast.USub(), ast.Num(5, lineno=0, col_offset=0),\n"
"                   lineno=0, col_offset=0)"
msgstr ""

#: ../../library/ast.rst:97
msgid "Abstract Grammar"
msgstr ""

#: ../../library/ast.rst:99
msgid "The abstract grammar is currently defined as follows:"
msgstr ""

#: ../../library/ast.rst:101
msgid ""
"-- ASDL's 7 builtin types are:\n"
"-- identifier, int, string, bytes, object, singleton, constant\n"
"--\n"
"-- singleton: None, True or False\n"
"-- constant can be None, whereas None means \"no value\" for object.\n"
"\n"
"module Python\n"
"{\n"
"    mod = Module(stmt* body)\n"
"        | Interactive(stmt* body)\n"
"        | Expression(expr body)\n"
"\n"
"        -- not really an actual node but useful in Jython's typesystem.\n"
"        | Suite(stmt* body)\n"
"\n"
"    stmt = FunctionDef(identifier name, arguments args,\n"
"                       stmt* body, expr* decorator_list, expr? returns)\n"
"          | AsyncFunctionDef(identifier name, arguments args,\n"
"                             stmt* body, expr* decorator_list, expr? "
"returns)\n"
"\n"
"          | ClassDef(identifier name,\n"
"             expr* bases,\n"
"             keyword* keywords,\n"
"             stmt* body,\n"
"             expr* decorator_list)\n"
"          | Return(expr? value)\n"
"\n"
"          | Delete(expr* targets)\n"
"          | Assign(expr* targets, expr value)\n"
"          | AugAssign(expr target, operator op, expr value)\n"
"          -- 'simple' indicates that we annotate simple name without "
"parens\n"
"          | AnnAssign(expr target, expr annotation, expr? value, int "
"simple)\n"
"\n"
"          -- use 'orelse' because else is a keyword in target languages\n"
"          | For(expr target, expr iter, stmt* body, stmt* orelse)\n"
"          | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse)\n"
"          | While(expr test, stmt* body, stmt* orelse)\n"
"          | If(expr test, stmt* body, stmt* orelse)\n"
"          | With(withitem* items, stmt* body)\n"
"          | AsyncWith(withitem* items, stmt* body)\n"
"\n"
"          | Raise(expr? exc, expr? cause)\n"
"          | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* "
"finalbody)\n"
"          | Assert(expr test, expr? msg)\n"
"\n"
"          | Import(alias* names)\n"
"          | ImportFrom(identifier? module, alias* names, int? level)\n"
"\n"
"          | Global(identifier* names)\n"
"          | Nonlocal(identifier* names)\n"
"          | Expr(expr value)\n"
"          | Pass | Break | Continue\n"
"\n"
"          -- XXX Jython will be different\n"
"          -- col_offset is the byte offset in the utf8 string the parser "
"uses\n"
"          attributes (int lineno, int col_offset)\n"
"\n"
"          -- BoolOp() can use left & right?\n"
"    expr = BoolOp(boolop op, expr* values)\n"
"         | BinOp(expr left, operator op, expr right)\n"
"         | UnaryOp(unaryop op, expr operand)\n"
"         | Lambda(arguments args, expr body)\n"
"         | IfExp(expr test, expr body, expr orelse)\n"
"         | Dict(expr* keys, expr* values)\n"
"         | Set(expr* elts)\n"
"         | ListComp(expr elt, comprehension* generators)\n"
"         | SetComp(expr elt, comprehension* generators)\n"
"         | DictComp(expr key, expr value, comprehension* generators)\n"
"         | GeneratorExp(expr elt, comprehension* generators)\n"
"         -- the grammar constrains where yield expressions can occur\n"
"         | Await(expr value)\n"
"         | Yield(expr? value)\n"
"         | YieldFrom(expr value)\n"
"         -- need sequences for compare to distinguish between\n"
"         -- x < 4 < 3 and (x < 4) < 3\n"
"         | Compare(expr left, cmpop* ops, expr* comparators)\n"
"         | Call(expr func, expr* args, keyword* keywords)\n"
"         | Num(object n) -- a number as a PyObject.\n"
"         | Str(string s) -- need to specify raw, unicode, etc?\n"
"         | FormattedValue(expr value, int? conversion, expr? format_spec)"
"\n"
"         | JoinedStr(expr* values)\n"
"         | Bytes(bytes s)\n"
"         | NameConstant(singleton value)\n"
"         | Ellipsis\n"
"         | Constant(constant value)\n"
"\n"
"         -- the following expression can appear in assignment context\n"
"         | Attribute(expr value, identifier attr, expr_context ctx)\n"
"         | Subscript(expr value, slice slice, expr_context ctx)\n"
"         | Starred(expr value, expr_context ctx)\n"
"         | Name(identifier id, expr_context ctx)\n"
"         | List(expr* elts, expr_context ctx)\n"
"         | Tuple(expr* elts, expr_context ctx)\n"
"\n"
"          -- col_offset is the byte offset in the utf8 string the parser "
"uses\n"
"          attributes (int lineno, int col_offset)\n"
"\n"
"    expr_context = Load | Store | Del | AugLoad | AugStore | Param\n"
"\n"
"    slice = Slice(expr? lower, expr? upper, expr? step)\n"
"          | ExtSlice(slice* dims)\n"
"          | Index(expr value)\n"
"\n"
"    boolop = And | Or\n"
"\n"
"    operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift\n"
"                 | RShift | BitOr | BitXor | BitAnd | FloorDiv\n"
"\n"
"    unaryop = Invert | Not | UAdd | USub\n"
"\n"
"    cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn\n"
"\n"
"    comprehension = (expr target, expr iter, expr* ifs, int is_async)\n"
"\n"
"    excepthandler = ExceptHandler(expr? type, identifier? name, stmt* "
"body)\n"
"                    attributes (int lineno, int col_offset)\n"
"\n"
"    arguments = (arg* args, arg? vararg, arg* kwonlyargs, expr* "
"kw_defaults,\n"
"                 arg? kwarg, expr* defaults)\n"
"\n"
"    arg = (identifier arg, expr? annotation)\n"
"           attributes (int lineno, int col_offset)\n"
"\n"
"    -- keyword arguments supplied to call (NULL identifier for **kwargs)\n"
"    keyword = (identifier? arg, expr value)\n"
"\n"
"    -- import name with optional 'as' alias.\n"
"    alias = (identifier name, identifier? asname)\n"
"\n"
"    withitem = (expr context_expr, expr? optional_vars)\n"
"}\n"
"\n"
msgstr ""

#: ../../library/ast.rst:106
msgid ":mod:`ast` Helpers"
msgstr ""

#: ../../library/ast.rst:108
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""

#: ../../library/ast.rst:113
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, ast.PyCF_ONLY_AST)``."
msgstr ""

#: ../../library/ast.rst:117 ../../library/ast.rst:135
msgid ""
"It is possible to crash the Python interpreter with a sufficiently "
"large/complex string due to stack depth limitations in Python's AST "
"compiler."
msgstr ""

#: ../../library/ast.rst:124
msgid ""
"Safely evaluate an expression node or a string containing a Python "
"literal or container display.  The string or node provided may only "
"consist of the following Python literal structures: strings, bytes, "
"numbers, tuples, lists, dicts, sets, booleans, and ``None``."
msgstr ""

#: ../../library/ast.rst:129
msgid ""
"This can be used for safely evaluating strings containing Python values "
"from untrusted sources without the need to parse the values oneself.  It "
"is not capable of evaluating arbitrarily complex expressions, for example"
" involving operators or indexing."
msgstr ""

#: ../../library/ast.rst:139
msgid "Now allows bytes and set literals."
msgstr ""

#: ../../library/ast.rst:145
msgid ""
"Return the docstring of the given *node* (which must be a "
":class:`FunctionDef`, :class:`ClassDef` or :class:`Module` node), or "
"``None`` if it has no docstring.  If *clean* is true, clean up the "
"docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""

#: ../../library/ast.rst:153
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects "
":attr:`lineno` and :attr:`col_offset` attributes for every node that "
"supports them.  This is rather tedious to fill in for generated nodes, so"
" this helper adds these attributes recursively where not already set, by "
"setting them to the values of the parent node.  It works recursively "
"starting at *node*."
msgstr ""

#: ../../library/ast.rst:162
msgid ""
"Increment the line number of each node in the tree starting at *node* by "
"*n*. This is useful to \"move code\" to a different location in a file."
msgstr ""

#: ../../library/ast.rst:168
msgid ""
"Copy source location (:attr:`lineno` and :attr:`col_offset`) from "
"*old_node* to *new_node* if possible, and return *new_node*."
msgstr ""

#: ../../library/ast.rst:174
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in "
"``node._fields`` that is present on *node*."
msgstr ""

#: ../../library/ast.rst:180
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are "
"nodes and all items of fields that are lists of nodes."
msgstr ""

#: ../../library/ast.rst:186
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""

#: ../../library/ast.rst:193
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a"
" visitor function for every node found.  This function may return a value"
" which is forwarded by the :meth:`visit` method."
msgstr ""

#: ../../library/ast.rst:197
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr ""

#: ../../library/ast.rst:202
msgid ""
"Visit a node.  The default implementation calls the method called "
":samp:`self.visit_{classname}` where *classname* is the name of the node "
"class, or :meth:`generic_visit` if that method doesn't exist."
msgstr ""

#: ../../library/ast.rst:208
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr ""

#: ../../library/ast.rst:210
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be"
" visited unless the visitor calls :meth:`generic_visit` or visits them "
"itself."
msgstr ""

#: ../../library/ast.rst:214
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists "
"(:class:`NodeTransformer`) that allows modifications."
msgstr ""

#: ../../library/ast.rst:221
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr ""

#: ../../library/ast.rst:224
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value "
"of the visitor methods to replace or remove the old node.  If the return "
"value of the visitor method is ``None``, the node will be removed from "
"its location, otherwise it is replaced with the return value.  The return"
" value may be the original node in which case no replacement takes place."
msgstr ""

#: ../../library/ast.rst:230
msgid ""
"Here is an example transformer that rewrites all occurrences of name "
"lookups (``foo``) to ``data['foo']``::"
msgstr ""

#: ../../library/ast.rst:233
msgid ""
"class RewriteName(NodeTransformer):\n"
"\n"
"    def visit_Name(self, node):\n"
"        return copy_location(Subscript(\n"
"            value=Name(id='data', ctx=Load()),\n"
"            slice=Index(value=Str(s=node.id)),\n"
"            ctx=node.ctx\n"
"        ), node)"
msgstr ""

#: ../../library/ast.rst:242
msgid ""
"Keep in mind that if the node you're operating on has child nodes you "
"must either transform the child nodes yourself or call the "
":meth:`generic_visit` method for the node first."
msgstr ""

#: ../../library/ast.rst:246
msgid ""
"For nodes that were part of a collection of statements (that applies to "
"all statement nodes), the visitor may also return a list of nodes rather "
"than just a single node."
msgstr ""

#: ../../library/ast.rst:250
msgid "Usually you use the transformer like this::"
msgstr ""

#: ../../library/ast.rst:252
msgid "node = YourTransformer().visit(node)"
msgstr ""

#: ../../library/ast.rst:257
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for"
" debugging purposes.  The returned string will show the names and the "
"values for fields.  This makes the code impossible to evaluate, so if "
"evaluation is wanted *annotate_fields* must be set to ``False``.  "
"Attributes such as line numbers and column offsets are not dumped by "
"default.  If this is wanted, *include_attributes* can be set to ``True``."
msgstr ""

#: ../../library/ast.rst:266
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.org/>`_, an "
"external documentation resource, has good details on working with Python "
"ASTs."
msgstr ""

