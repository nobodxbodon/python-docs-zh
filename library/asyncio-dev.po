# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-27 02:24-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.3\n"

#: ../../library/asyncio-dev.rst:6
msgid "Develop with asyncio"
msgstr ""

#: ../../library/asyncio-dev.rst:8
msgid ""
"Asynchronous programming is different than classical \"sequential\" "
"programming. This page lists common traps and explains how to avoid them."
msgstr ""

#: ../../library/asyncio-dev.rst:15
msgid "Debug mode of asyncio"
msgstr ""

#: ../../library/asyncio-dev.rst:17
msgid ""
"The implementation of :mod:`asyncio` has been written for performance. In"
" order to ease the development of asynchronous code, you may wish to "
"enable *debug mode*."
msgstr ""

#: ../../library/asyncio-dev.rst:21
msgid "To enable all debug checks for an application:"
msgstr ""

#: ../../library/asyncio-dev.rst:23
msgid ""
"Enable the asyncio debug mode globally by setting the environment "
"variable :envvar:`PYTHONASYNCIODEBUG` to ``1``, or by calling "
":meth:`AbstractEventLoop.set_debug`."
msgstr ""

#: ../../library/asyncio-dev.rst:25
msgid ""
"Set the log level of the :ref:`asyncio logger <asyncio-logger>` to "
":py:data:`logging.DEBUG`. For example, call "
"``logging.basicConfig(level=logging.DEBUG)`` at startup."
msgstr ""

#: ../../library/asyncio-dev.rst:28
msgid ""
"Configure the :mod:`warnings` module to display :exc:`ResourceWarning` "
"warnings. For example, use the ``-Wdefault`` command line option of "
"Python to display them."
msgstr ""

#: ../../library/asyncio-dev.rst:32
msgid "Examples debug checks:"
msgstr ""

#: ../../library/asyncio-dev.rst:34
msgid ""
"Log :ref:`coroutines defined but never \"yielded from\" <asyncio-"
"coroutine-not-scheduled>`"
msgstr ""

#: ../../library/asyncio-dev.rst:36
msgid ""
":meth:`~AbstractEventLoop.call_soon` and "
":meth:`~AbstractEventLoop.call_at` methods raise an exception if they are"
" called from the wrong thread."
msgstr ""

#: ../../library/asyncio-dev.rst:38
msgid "Log the execution time of the selector"
msgstr ""

#: ../../library/asyncio-dev.rst:39
msgid ""
"Log callbacks taking more than 100 ms to be executed. The "
":attr:`AbstractEventLoop.slow_callback_duration` attribute is the minimum"
" duration in seconds of \"slow\" callbacks."
msgstr ""

#: ../../library/asyncio-dev.rst:42
msgid ""
":exc:`ResourceWarning` warnings are emitted when transports and event "
"loops are :ref:`not closed explicitly <asyncio-close-transports>`."
msgstr ""

#: ../../library/asyncio-dev.rst:47
msgid ""
"The :meth:`AbstractEventLoop.set_debug` method and the :ref:`asyncio "
"logger <asyncio-logger>`."
msgstr ""

#: ../../library/asyncio-dev.rst:52
msgid "Cancellation"
msgstr ""

#: ../../library/asyncio-dev.rst:54
msgid ""
"Cancellation of tasks is not common in classic programming. In "
"asynchronous programming, not only is it something common, but you have "
"to prepare your code to handle it."
msgstr ""

#: ../../library/asyncio-dev.rst:58
msgid ""
"Futures and tasks can be cancelled explicitly with their "
":meth:`Future.cancel` method. The :func:`wait_for` function cancels the "
"waited task when the timeout occurs. There are many other cases where a "
"task can be cancelled indirectly."
msgstr ""

#: ../../library/asyncio-dev.rst:62
msgid ""
"Don't call :meth:`~Future.set_result` or :meth:`~Future.set_exception` "
"method of :class:`Future` if the future is cancelled: it would fail with "
"an exception. For example, write::"
msgstr ""

#: ../../library/asyncio-dev.rst:66
msgid ""
"if not fut.cancelled():\n"
"    fut.set_result('done')"
msgstr ""

#: ../../library/asyncio-dev.rst:69
msgid ""
"Don't schedule directly a call to the :meth:`~Future.set_result` or the "
":meth:`~Future.set_exception` method of a future with "
":meth:`AbstractEventLoop.call_soon`: the future can be cancelled before "
"its method is called."
msgstr ""

#: ../../library/asyncio-dev.rst:74
msgid ""
"If you wait for a future, you should check early if the future was "
"cancelled to avoid useless operations. Example::"
msgstr ""

#: ../../library/asyncio-dev.rst:77
msgid ""
"@coroutine\n"
"def slow_operation(fut):\n"
"    if fut.cancelled():\n"
"        return\n"
"    # ... slow computation ...\n"
"    yield from fut\n"
"    # ..."
msgstr ""

#: ../../library/asyncio-dev.rst:85
msgid "The :func:`shield` function can also be used to ignore cancellation."
msgstr ""

#: ../../library/asyncio-dev.rst:91
msgid "Concurrency and multithreading"
msgstr ""

#: ../../library/asyncio-dev.rst:93
msgid ""
"An event loop runs in a thread and executes all callbacks and tasks in "
"the same thread. While a task is running in the event loop, no other task"
" is running in the same thread. But when the task uses ``yield from``, "
"the task is suspended and the event loop executes the next task."
msgstr ""

#: ../../library/asyncio-dev.rst:98
msgid ""
"To schedule a callback from a different thread, the "
":meth:`AbstractEventLoop.call_soon_threadsafe` method should be used. "
"Example::"
msgstr ""

#: ../../library/asyncio-dev.rst:101
msgid "loop.call_soon_threadsafe(callback, *args)"
msgstr ""

#: ../../library/asyncio-dev.rst:103
msgid ""
"Most asyncio objects are not thread safe. You should only worry if you "
"access objects outside the event loop. For example, to cancel a future, "
"don't call directly its :meth:`Future.cancel` method, but::"
msgstr ""

#: ../../library/asyncio-dev.rst:107
msgid "loop.call_soon_threadsafe(fut.cancel)"
msgstr ""

#: ../../library/asyncio-dev.rst:109
msgid ""
"To handle signals and to execute subprocesses, the event loop must be run"
" in the main thread."
msgstr ""

#: ../../library/asyncio-dev.rst:112
msgid ""
"To schedule a coroutine object from a different thread, the "
":func:`run_coroutine_threadsafe` function should be used. It returns a "
":class:`concurrent.futures.Future` to access the result::"
msgstr ""

#: ../../library/asyncio-dev.rst:116
msgid ""
"future = asyncio.run_coroutine_threadsafe(coro_func(), loop)\n"
"result = future.result(timeout)  # Wait for the result with a timeout"
msgstr ""

#: ../../library/asyncio-dev.rst:119
msgid ""
"The :meth:`AbstractEventLoop.run_in_executor` method can be used with a "
"thread pool executor to execute a callback in different thread to not "
"block the thread of the event loop."
msgstr ""

#: ../../library/asyncio-dev.rst:125
msgid ""
"The :ref:`Synchronization primitives <asyncio-sync>` section describes "
"ways to synchronize tasks."
msgstr ""

#: ../../library/asyncio-dev.rst:128
msgid ""
"The :ref:`Subprocess and threads <asyncio-subprocess-threads>` section "
"lists asyncio limitations to run subprocesses from different threads."
msgstr ""

#: ../../library/asyncio-dev.rst:137
msgid "Handle blocking functions correctly"
msgstr ""

#: ../../library/asyncio-dev.rst:139
msgid ""
"Blocking functions should not be called directly. For example, if a "
"function blocks for 1 second, other tasks are delayed by 1 second which "
"can have an important impact on reactivity."
msgstr ""

#: ../../library/asyncio-dev.rst:143
msgid ""
"For networking and subprocesses, the :mod:`asyncio` module provides high-"
"level APIs like :ref:`protocols <asyncio-protocol>`."
msgstr ""

#: ../../library/asyncio-dev.rst:146
msgid ""
"An executor can be used to run a task in a different thread or even in a "
"different process, to not block the thread of the event loop. See the "
":meth:`AbstractEventLoop.run_in_executor` method."
msgstr ""

#: ../../library/asyncio-dev.rst:152
msgid ""
"The :ref:`Delayed calls <asyncio-delayed-calls>` section details how the "
"event loop handles time."
msgstr ""

#: ../../library/asyncio-dev.rst:159
msgid "Logging"
msgstr ""

#: ../../library/asyncio-dev.rst:161
msgid ""
"The :mod:`asyncio` module logs information with the :mod:`logging` module"
" in the logger ``'asyncio'``."
msgstr ""

#: ../../library/asyncio-dev.rst:164
msgid ""
"The default log level for the :mod:`asyncio` module is "
":py:data:`logging.INFO`. For those not wanting such verbosity from "
":mod:`asyncio` the log level can be changed.  For example, to change the "
"level to :py:data:`logging.WARNING`:"
msgstr ""

#: ../../library/asyncio-dev.rst:168
msgid "logging.getLogger('asyncio').setLevel(logging.WARNING)"
msgstr ""

#: ../../library/asyncio-dev.rst:176
msgid "Detect coroutine objects never scheduled"
msgstr ""

#: ../../library/asyncio-dev.rst:178
msgid ""
"When a coroutine function is called and its result is not passed to "
":func:`ensure_future` or to the :meth:`AbstractEventLoop.create_task` "
"method, the execution of the coroutine object will never be scheduled "
"which is probably a bug.  :ref:`Enable the debug mode of asyncio "
"<asyncio-debug-mode>` to :ref:`log a warning <asyncio-logger>` to detect "
"it."
msgstr ""

#: ../../library/asyncio-dev.rst:184
msgid "Example with the bug::"
msgstr ""

#: ../../library/asyncio-dev.rst:186
msgid ""
"import asyncio\n"
"\n"
"@asyncio.coroutine\n"
"def test():\n"
"    print(\"never scheduled\")\n"
"\n"
"test()"
msgstr ""

#: ../../library/asyncio-dev.rst:194
msgid "Output in debug mode::"
msgstr ""

#: ../../library/asyncio-dev.rst:196
msgid ""
"Coroutine test() at test.py:3 was never yielded from\n"
"Coroutine object created at (most recent call last):\n"
"  File \"test.py\", line 7, in <module>\n"
"    test()"
msgstr ""

#: ../../library/asyncio-dev.rst:201
msgid ""
"The fix is to call the :func:`ensure_future` function or the "
":meth:`AbstractEventLoop.create_task` method with the coroutine object."
msgstr ""

#: ../../library/asyncio-dev.rst:206
msgid ":ref:`Pending task destroyed <asyncio-pending-task-destroyed>`."
msgstr ""

#: ../../library/asyncio-dev.rst:210
msgid "Detect exceptions never consumed"
msgstr ""

#: ../../library/asyncio-dev.rst:212
msgid ""
"Python usually calls :func:`sys.excepthook` on unhandled exceptions. If "
":meth:`Future.set_exception` is called, but the exception is never "
"consumed, :func:`sys.excepthook` is not called. Instead, :ref:`a log is "
"emitted <asyncio-logger>` when the future is deleted by the garbage "
"collector, with the traceback where the exception was raised."
msgstr ""

#: ../../library/asyncio-dev.rst:218
msgid "Example of unhandled exception::"
msgstr ""

#: ../../library/asyncio-dev.rst:220
msgid ""
"import asyncio\n"
"\n"
"@asyncio.coroutine\n"
"def bug():\n"
"    raise Exception(\"not consumed\")\n"
"\n"
"loop = asyncio.get_event_loop()\n"
"asyncio.ensure_future(bug())\n"
"loop.run_forever()\n"
"loop.close()"
msgstr ""

#: ../../library/asyncio-dev.rst:231
msgid "Output::"
msgstr ""

#: ../../library/asyncio-dev.rst:233
msgid ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<coro() done, defined at "
"asyncio/coroutines.py:139> exception=Exception('not consumed',)>\n"
"Traceback (most recent call last):\n"
"  File \"asyncio/tasks.py\", line 237, in _step\n"
"    result = next(coro)\n"
"  File \"asyncio/coroutines.py\", line 141, in coro\n"
"    res = func(*args, **kw)\n"
"  File \"test.py\", line 5, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"
msgstr ""

#: ../../library/asyncio-dev.rst:244
msgid ""
":ref:`Enable the debug mode of asyncio <asyncio-debug-mode>` to get the "
"traceback where the task was created. Output in debug mode::"
msgstr ""

#: ../../library/asyncio-dev.rst:247
msgid ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3> "
"exception=Exception('not consumed',) created at test.py:8>\n"
"source_traceback: Object created at (most recent call last):\n"
"  File \"test.py\", line 8, in <module>\n"
"    asyncio.ensure_future(bug())\n"
"Traceback (most recent call last):\n"
"  File \"asyncio/tasks.py\", line 237, in _step\n"
"    result = next(coro)\n"
"  File \"asyncio/coroutines.py\", line 79, in __next__\n"
"    return next(self.gen)\n"
"  File \"asyncio/coroutines.py\", line 141, in coro\n"
"    res = func(*args, **kw)\n"
"  File \"test.py\", line 5, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"
msgstr ""

#: ../../library/asyncio-dev.rst:263
msgid ""
"There are different options to fix this issue. The first option is to "
"chain the coroutine in another coroutine and use classic try/except::"
msgstr ""

#: ../../library/asyncio-dev.rst:266
msgid ""
"@asyncio.coroutine\n"
"def handle_exception():\n"
"    try:\n"
"        yield from bug()\n"
"    except Exception:\n"
"        print(\"exception consumed\")\n"
"\n"
"loop = asyncio.get_event_loop()\n"
"asyncio.ensure_future(handle_exception())\n"
"loop.run_forever()\n"
"loop.close()"
msgstr ""

#: ../../library/asyncio-dev.rst:278
msgid ""
"Another option is to use the :meth:`AbstractEventLoop.run_until_complete`"
" function::"
msgstr ""

#: ../../library/asyncio-dev.rst:281
msgid ""
"task = asyncio.ensure_future(bug())\n"
"try:\n"
"    loop.run_until_complete(task)\n"
"except Exception:\n"
"    print(\"exception consumed\")"
msgstr ""

#: ../../library/asyncio-dev.rst:289
msgid "The :meth:`Future.exception` method."
msgstr ""

#: ../../library/asyncio-dev.rst:293
msgid "Chain coroutines correctly"
msgstr ""

#: ../../library/asyncio-dev.rst:295
msgid ""
"When a coroutine function calls other coroutine functions and tasks, they"
" should be chained explicitly with ``yield from``. Otherwise, the "
"execution is not guaranteed to be sequential."
msgstr ""

#: ../../library/asyncio-dev.rst:299
msgid ""
"Example with different bugs using :func:`asyncio.sleep` to simulate slow "
"operations::"
msgstr ""

#: ../../library/asyncio-dev.rst:302
#, python-format
msgid ""
"import asyncio\n"
"\n"
"@asyncio.coroutine\n"
"def create():\n"
"    yield from asyncio.sleep(3.0)\n"
"    print(\"(1) create file\")\n"
"\n"
"@asyncio.coroutine\n"
"def write():\n"
"    yield from asyncio.sleep(1.0)\n"
"    print(\"(2) write into file\")\n"
"\n"
"@asyncio.coroutine\n"
"def close():\n"
"    print(\"(3) close file\")\n"
"\n"
"@asyncio.coroutine\n"
"def test():\n"
"    asyncio.ensure_future(create())\n"
"    asyncio.ensure_future(write())\n"
"    asyncio.ensure_future(close())\n"
"    yield from asyncio.sleep(2.0)\n"
"    loop.stop()\n"
"\n"
"loop = asyncio.get_event_loop()\n"
"asyncio.ensure_future(test())\n"
"loop.run_forever()\n"
"print(\"Pending tasks at exit: %s\" % asyncio.Task.all_tasks(loop))\n"
"loop.close()"
msgstr ""

#: ../../library/asyncio-dev.rst:332
msgid "Expected output:"
msgstr ""

#: ../../library/asyncio-dev.rst:334
msgid ""
"(1) create file\n"
"(2) write into file\n"
"(3) close file\n"
"Pending tasks at exit: set()"
msgstr ""

#: ../../library/asyncio-dev.rst:341
msgid "Actual output:"
msgstr ""

#: ../../library/asyncio-dev.rst:343
msgid ""
"(3) close file\n"
"(2) write into file\n"
"Pending tasks at exit: {<Task pending create() at test.py:7 "
"wait_for=<Future pending cb=[Task._wakeup()]>>}\n"
"Task was destroyed but it is pending!\n"
"task: <Task pending create() done at test.py:5 wait_for=<Future pending "
"cb=[Task._wakeup()]>>"
msgstr ""

#: ../../library/asyncio-dev.rst:351
msgid ""
"The loop stopped before the ``create()`` finished, ``close()`` has been "
"called before ``write()``, whereas coroutine functions were called in "
"this order: ``create()``, ``write()``, ``close()``."
msgstr ""

#: ../../library/asyncio-dev.rst:355
msgid "To fix the example, tasks must be marked with ``yield from``::"
msgstr ""

#: ../../library/asyncio-dev.rst:357
msgid ""
"@asyncio.coroutine\n"
"def test():\n"
"    yield from asyncio.ensure_future(create())\n"
"    yield from asyncio.ensure_future(write())\n"
"    yield from asyncio.ensure_future(close())\n"
"    yield from asyncio.sleep(2.0)\n"
"    loop.stop()"
msgstr ""

#: ../../library/asyncio-dev.rst:365
msgid "Or without ``asyncio.ensure_future()``::"
msgstr ""

#: ../../library/asyncio-dev.rst:367
msgid ""
"@asyncio.coroutine\n"
"def test():\n"
"    yield from create()\n"
"    yield from write()\n"
"    yield from close()\n"
"    yield from asyncio.sleep(2.0)\n"
"    loop.stop()"
msgstr ""

#: ../../library/asyncio-dev.rst:379
msgid "Pending task destroyed"
msgstr ""

#: ../../library/asyncio-dev.rst:381
msgid ""
"If a pending task is destroyed, the execution of its wrapped "
":ref:`coroutine <coroutine>` did not complete. It is probably a bug and "
"so a warning is logged."
msgstr ""

#: ../../library/asyncio-dev.rst:384
msgid "Example of log:"
msgstr ""

#: ../../library/asyncio-dev.rst:386
msgid ""
"Task was destroyed but it is pending!\n"
"task: <Task pending coro=<kill_me() done, defined at test.py:5> "
"wait_for=<Future pending cb=[Task._wakeup()]>>"
msgstr ""

#: ../../library/asyncio-dev.rst:391
msgid ""
":ref:`Enable the debug mode of asyncio <asyncio-debug-mode>` to get the "
"traceback where the task was created. Example of log in debug mode:"
msgstr ""

#: ../../library/asyncio-dev.rst:394
msgid ""
"Task was destroyed but it is pending!\n"
"source_traceback: Object created at (most recent call last):\n"
"  File \"test.py\", line 15, in <module>\n"
"    task = asyncio.ensure_future(coro, loop=loop)\n"
"task: <Task pending coro=<kill_me() done, defined at test.py:5> "
"wait_for=<Future pending cb=[Task._wakeup()] created at test.py:7> "
"created at test.py:15>"
msgstr ""

#: ../../library/asyncio-dev.rst:405
msgid ""
":ref:`Detect coroutine objects never scheduled <asyncio-coroutine-not-"
"scheduled>`."
msgstr ""

#: ../../library/asyncio-dev.rst:410
msgid "Close transports and event loops"
msgstr ""

#: ../../library/asyncio-dev.rst:412
msgid ""
"When a transport is no more needed, call its ``close()`` method to "
"release resources. Event loops must also be closed explicitly."
msgstr ""

#: ../../library/asyncio-dev.rst:415
msgid ""
"If a transport or an event loop is not closed explicitly, a "
":exc:`ResourceWarning` warning will be emitted in its destructor. By "
"default, :exc:`ResourceWarning` warnings are ignored. The :ref:`Debug "
"mode of asyncio <asyncio-debug-mode>` section explains how to display "
"them."
msgstr ""

