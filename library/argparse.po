# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-27 02:24-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.3\n"

#: ../../library/argparse.rst:2
msgid ""
":mod:`argparse` --- Parser for command-line options, arguments and sub-"
"commands"
msgstr ""

#: ../../library/argparse.rst:12
msgid "**Source code:** :source:`Lib/argparse.py`"
msgstr ""

#: ../../library/argparse.rst:18
msgid ""
"This page contains the API reference information. For a more gentle "
"introduction to Python command-line parsing, have a look at the "
":ref:`argparse tutorial <argparse-tutorial>`."
msgstr ""

#: ../../library/argparse.rst:22
msgid ""
"The :mod:`argparse` module makes it easy to write user-friendly command-"
"line interfaces. The program defines what arguments it requires, and "
":mod:`argparse` will figure out how to parse those out of "
":data:`sys.argv`.  The :mod:`argparse` module also automatically "
"generates help and usage messages and issues errors when users give the "
"program invalid arguments."
msgstr ""

#: ../../library/argparse.rst:30
msgid "Example"
msgstr ""

#: ../../library/argparse.rst:32
msgid ""
"The following code is a Python program that takes a list of integers and "
"produces either the sum or the max::"
msgstr ""

#: ../../library/argparse.rst:35
msgid ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser(description='Process some integers.')\n"
"parser.add_argument('integers', metavar='N', type=int, nargs='+',\n"
"                    help='an integer for the accumulator')\n"
"parser.add_argument('--sum', dest='accumulate', action='store_const',\n"
"                    const=sum, default=max,\n"
"                    help='sum the integers (default: find the max)')\n"
"\n"
"args = parser.parse_args()\n"
"print(args.accumulate(args.integers))"
msgstr ""

#: ../../library/argparse.rst:47
msgid ""
"Assuming the Python code above is saved into a file called ``prog.py``, "
"it can be run at the command line and provides useful help messages:"
msgstr ""

#: ../../library/argparse.rst:50
msgid ""
"$ python prog.py -h\n"
"usage: prog.py [-h] [--sum] N [N ...]\n"
"\n"
"Process some integers.\n"
"\n"
"positional arguments:\n"
" N           an integer for the accumulator\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit\n"
" --sum       sum the integers (default: find the max)"
msgstr ""

#: ../../library/argparse.rst:64
msgid ""
"When run with the appropriate arguments, it prints either the sum or the "
"max of the command-line integers:"
msgstr ""

#: ../../library/argparse.rst:67
msgid ""
"$ python prog.py 1 2 3 4\n"
"4\n"
"\n"
"$ python prog.py 1 2 3 4 --sum\n"
"10"
msgstr ""

#: ../../library/argparse.rst:75
msgid "If invalid arguments are passed in, it will issue an error:"
msgstr ""

#: ../../library/argparse.rst:77
msgid ""
"$ python prog.py a b c\n"
"usage: prog.py [-h] [--sum] N [N ...]\n"
"prog.py: error: argument N: invalid int value: 'a'"
msgstr ""

#: ../../library/argparse.rst:83
msgid "The following sections walk you through this example."
msgstr ""

#: ../../library/argparse.rst:87
msgid "Creating a parser"
msgstr ""

#: ../../library/argparse.rst:89
msgid ""
"The first step in using the :mod:`argparse` is creating an "
":class:`ArgumentParser` object::"
msgstr ""

#: ../../library/argparse.rst:92
msgid ">>> parser = argparse.ArgumentParser(description='Process some integers.')"
msgstr ""

#: ../../library/argparse.rst:94
msgid ""
"The :class:`ArgumentParser` object will hold all the information "
"necessary to parse the command line into Python data types."
msgstr ""

#: ../../library/argparse.rst:99
msgid "Adding arguments"
msgstr ""

#: ../../library/argparse.rst:101
msgid ""
"Filling an :class:`ArgumentParser` with information about program "
"arguments is done by making calls to the "
":meth:`~ArgumentParser.add_argument` method. Generally, these calls tell "
"the :class:`ArgumentParser` how to take the strings on the command line "
"and turn them into objects.  This information is stored and used when "
":meth:`~ArgumentParser.parse_args` is called. For example::"
msgstr ""

#: ../../library/argparse.rst:107
msgid ""
">>> parser.add_argument('integers', metavar='N', type=int, nargs='+',\n"
"...                     help='an integer for the accumulator')\n"
">>> parser.add_argument('--sum', dest='accumulate', action='store_const',"
"\n"
"...                     const=sum, default=max,\n"
"...                     help='sum the integers (default: find the max)')"
msgstr ""

#: ../../library/argparse.rst:113
msgid ""
"Later, calling :meth:`~ArgumentParser.parse_args` will return an object "
"with two attributes, ``integers`` and ``accumulate``.  The ``integers`` "
"attribute will be a list of one or more ints, and the ``accumulate`` "
"attribute will be either the :func:`sum` function, if ``--sum`` was "
"specified at the command line, or the :func:`max` function if it was not."
msgstr ""

#: ../../library/argparse.rst:121
msgid "Parsing arguments"
msgstr ""

#: ../../library/argparse.rst:123
msgid ""
":class:`ArgumentParser` parses arguments through the "
":meth:`~ArgumentParser.parse_args` method.  This will inspect the command"
" line, convert each argument to the appropriate type and then invoke the "
"appropriate action. In most cases, this means a simple :class:`Namespace`"
" object will be built up from attributes parsed out of the command line::"
msgstr ""

#: ../../library/argparse.rst:129
msgid ""
">>> parser.parse_args(['--sum', '7', '-1', '42'])\n"
"Namespace(accumulate=<built-in function sum>, integers=[7, -1, 42])"
msgstr ""

#: ../../library/argparse.rst:132
msgid ""
"In a script, :meth:`~ArgumentParser.parse_args` will typically be called "
"with no arguments, and the :class:`ArgumentParser` will automatically "
"determine the command-line arguments from :data:`sys.argv`."
msgstr ""

#: ../../library/argparse.rst:138
msgid "ArgumentParser objects"
msgstr ""

#: ../../library/argparse.rst:147
msgid ""
"Create a new :class:`ArgumentParser` object. All parameters should be "
"passed as keyword arguments. Each parameter has its own more detailed "
"description below, but in short they are:"
msgstr ""

#: ../../library/argparse.rst:151
msgid "prog_ - The name of the program (default: ``sys.argv[0]``)"
msgstr ""

#: ../../library/argparse.rst:153
msgid ""
"usage_ - The string describing the program usage (default: generated from"
" arguments added to parser)"
msgstr ""

#: ../../library/argparse.rst:156
msgid "description_ - Text to display before the argument help (default: none)"
msgstr ""

#: ../../library/argparse.rst:158
msgid "epilog_ - Text to display after the argument help (default: none)"
msgstr ""

#: ../../library/argparse.rst:160
msgid ""
"parents_ - A list of :class:`ArgumentParser` objects whose arguments "
"should also be included"
msgstr ""

#: ../../library/argparse.rst:163
msgid "formatter_class_ - A class for customizing the help output"
msgstr ""

#: ../../library/argparse.rst:165
msgid ""
"prefix_chars_ - The set of characters that prefix optional arguments "
"(default: '-')"
msgstr ""

#: ../../library/argparse.rst:168
msgid ""
"fromfile_prefix_chars_ - The set of characters that prefix files from "
"which additional arguments should be read (default: ``None``)"
msgstr ""

#: ../../library/argparse.rst:171
msgid ""
"argument_default_ - The global default value for arguments (default: "
"``None``)"
msgstr ""

#: ../../library/argparse.rst:174
msgid ""
"conflict_handler_ - The strategy for resolving conflicting optionals "
"(usually unnecessary)"
msgstr ""

#: ../../library/argparse.rst:177
msgid "add_help_ - Add a ``-h/--help`` option to the parser (default: ``True``)"
msgstr ""

#: ../../library/argparse.rst:179
msgid ""
"allow_abbrev_ - Allows long options to be abbreviated if the abbreviation"
" is unambiguous. (default: ``True``)"
msgstr ""

#: ../../library/argparse.rst:182
msgid "*allow_abbrev* parameter was added."
msgstr ""

#: ../../library/argparse.rst:185 ../../library/argparse.rst:683
msgid "The following sections describe how each of these are used."
msgstr ""

#: ../../library/argparse.rst:189
msgid "prog"
msgstr ""

#: ../../library/argparse.rst:191
msgid ""
"By default, :class:`ArgumentParser` objects use ``sys.argv[0]`` to "
"determine how to display the name of the program in help messages.  This "
"default is almost always desirable because it will make the help messages"
" match how the program was invoked on the command line.  For example, "
"consider a file named ``myprogram.py`` with the following code::"
msgstr ""

#: ../../library/argparse.rst:197 ../../library/argparse.rst:603
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('--foo', help='foo help')\n"
"args = parser.parse_args()"
msgstr ""

#: ../../library/argparse.rst:202
msgid ""
"The help for this program will display ``myprogram.py`` as the program "
"name (regardless of where the program was invoked from):"
msgstr ""

#: ../../library/argparse.rst:205
msgid ""
"$ python myprogram.py --help\n"
"usage: myprogram.py [-h] [--foo FOO]\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   foo help\n"
"$ cd ..\n"
"$ python subdir/myprogram.py --help\n"
"usage: myprogram.py [-h] [--foo FOO]\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   foo help"
msgstr ""

#: ../../library/argparse.rst:221
msgid ""
"To change this default behavior, another value can be supplied using the "
"``prog=`` argument to :class:`ArgumentParser`::"
msgstr ""

#: ../../library/argparse.rst:224
msgid ""
">>> parser = argparse.ArgumentParser(prog='myprogram')\n"
">>> parser.print_help()\n"
"usage: myprogram [-h]\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit"
msgstr ""

#: ../../library/argparse.rst:231
#, python-format
msgid ""
"Note that the program name, whether determined from ``sys.argv[0]`` or "
"from the ``prog=`` argument, is available to help messages using the "
"``%(prog)s`` format specifier."
msgstr ""

#: ../../library/argparse.rst:237
#, python-format
msgid ""
">>> parser = argparse.ArgumentParser(prog='myprogram')\n"
">>> parser.add_argument('--foo', help='foo of the %(prog)s program')\n"
">>> parser.print_help()\n"
"usage: myprogram [-h] [--foo FOO]\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   foo of the myprogram program"
msgstr ""

#: ../../library/argparse.rst:248
msgid "usage"
msgstr ""

#: ../../library/argparse.rst:250
msgid ""
"By default, :class:`ArgumentParser` calculates the usage message from the"
" arguments it contains::"
msgstr ""

#: ../../library/argparse.rst:253
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', nargs='?', help='foo help')\n"
">>> parser.add_argument('bar', nargs='+', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo [FOO]] bar [bar ...]\n"
"\n"
"positional arguments:\n"
" bar          bar help\n"
"\n"
"optional arguments:\n"
" -h, --help   show this help message and exit\n"
" --foo [FOO]  foo help"
msgstr ""

#: ../../library/argparse.rst:266
msgid ""
"The default message can be overridden with the ``usage=`` keyword "
"argument::"
msgstr ""

#: ../../library/argparse.rst:268
#, python-format
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s "
"[options]')\n"
">>> parser.add_argument('--foo', nargs='?', help='foo help')\n"
">>> parser.add_argument('bar', nargs='+', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [options]\n"
"\n"
"positional arguments:\n"
" bar          bar help\n"
"\n"
"optional arguments:\n"
" -h, --help   show this help message and exit\n"
" --foo [FOO]  foo help"
msgstr ""

#: ../../library/argparse.rst:281
#, python-format
msgid ""
"The ``%(prog)s`` format specifier is available to fill in the program "
"name in your usage messages."
msgstr ""

#: ../../library/argparse.rst:286
msgid "description"
msgstr ""

#: ../../library/argparse.rst:288
msgid ""
"Most calls to the :class:`ArgumentParser` constructor will use the "
"``description=`` keyword argument.  This argument gives a brief "
"description of what the program does and how it works.  In help messages,"
" the description is displayed between the command-line usage string and "
"the help messages for the various arguments::"
msgstr ""

#: ../../library/argparse.rst:294
msgid ""
">>> parser = argparse.ArgumentParser(description='A foo that bars')\n"
">>> parser.print_help()\n"
"usage: argparse.py [-h]\n"
"\n"
"A foo that bars\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit"
msgstr ""

#: ../../library/argparse.rst:303
msgid ""
"By default, the description will be line-wrapped so that it fits within "
"the given space.  To change this behavior, see the formatter_class_ "
"argument."
msgstr ""

#: ../../library/argparse.rst:308
msgid "epilog"
msgstr ""

#: ../../library/argparse.rst:310
msgid ""
"Some programs like to display additional description of the program after"
" the description of the arguments.  Such text can be specified using the "
"``epilog=`` argument to :class:`ArgumentParser`::"
msgstr ""

#: ../../library/argparse.rst:314
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     description='A foo that bars',\n"
"...     epilog=\"And that's how you'd foo a bar\")\n"
">>> parser.print_help()\n"
"usage: argparse.py [-h]\n"
"\n"
"A foo that bars\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit\n"
"\n"
"And that's how you'd foo a bar"
msgstr ""

#: ../../library/argparse.rst:327
msgid ""
"As with the description_ argument, the ``epilog=`` text is by default "
"line-wrapped, but this behavior can be adjusted with the formatter_class_"
" argument to :class:`ArgumentParser`."
msgstr ""

#: ../../library/argparse.rst:333
msgid "parents"
msgstr ""

#: ../../library/argparse.rst:335
msgid ""
"Sometimes, several parsers share a common set of arguments. Rather than "
"repeating the definitions of these arguments, a single parser with all "
"the shared arguments and passed to ``parents=`` argument to "
":class:`ArgumentParser` can be used.  The ``parents=`` argument takes a "
"list of :class:`ArgumentParser` objects, collects all the positional and "
"optional actions from them, and adds these actions to the "
":class:`ArgumentParser` object being constructed::"
msgstr ""

#: ../../library/argparse.rst:342
msgid ""
">>> parent_parser = argparse.ArgumentParser(add_help=False)\n"
">>> parent_parser.add_argument('--parent', type=int)\n"
"\n"
">>> foo_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> foo_parser.add_argument('foo')\n"
">>> foo_parser.parse_args(['--parent', '2', 'XXX'])\n"
"Namespace(foo='XXX', parent=2)\n"
"\n"
">>> bar_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> bar_parser.add_argument('--bar')\n"
">>> bar_parser.parse_args(['--bar', 'YYY'])\n"
"Namespace(bar='YYY', parent=None)"
msgstr ""

#: ../../library/argparse.rst:355
msgid ""
"Note that most parent parsers will specify ``add_help=False``.  "
"Otherwise, the :class:`ArgumentParser` will see two ``-h/--help`` options"
" (one in the parent and one in the child) and raise an error."
msgstr ""

#: ../../library/argparse.rst:360
msgid ""
"You must fully initialize the parsers before passing them via "
"``parents=``. If you change the parent parsers after the child parser, "
"those changes will not be reflected in the child."
msgstr ""

#: ../../library/argparse.rst:366
msgid "formatter_class"
msgstr ""

#: ../../library/argparse.rst:368
msgid ""
":class:`ArgumentParser` objects allow the help formatting to be "
"customized by specifying an alternate formatting class.  Currently, there"
" are four such classes:"
msgstr ""

#: ../../library/argparse.rst:377
msgid ""
":class:`RawDescriptionHelpFormatter` and :class:`RawTextHelpFormatter` "
"give more control over how textual descriptions are displayed. By "
"default, :class:`ArgumentParser` objects line-wrap the description_ and "
"epilog_ texts in command-line help messages::"
msgstr ""

#: ../../library/argparse.rst:382
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     description='''this description\n"
"...         was indented weird\n"
"...             but that is okay''',\n"
"...     epilog='''\n"
"...             likewise for this epilog whose whitespace will\n"
"...         be cleaned up and whose words will be wrapped\n"
"...         across a couple lines''')\n"
">>> parser.print_help()\n"
"usage: PROG [-h]\n"
"\n"
"this description was indented weird but that is okay\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit\n"
"\n"
"likewise for this epilog whose whitespace will be cleaned up and whose "
"words\n"
"will be wrapped across a couple lines"
msgstr ""

#: ../../library/argparse.rst:402
msgid ""
"Passing :class:`RawDescriptionHelpFormatter` as ``formatter_class=`` "
"indicates that description_ and epilog_ are already correctly formatted "
"and should not be line-wrapped::"
msgstr ""

#: ../../library/argparse.rst:406
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.RawDescriptionHelpFormatter,\n"
"...     description=textwrap.dedent('''\\\n"
"...         Please do not mess up this text!\n"
"...         --------------------------------\n"
"...             I have indented it\n"
"...             exactly the way\n"
"...             I want it\n"
"...         '''))\n"
">>> parser.print_help()\n"
"usage: PROG [-h]\n"
"\n"
"Please do not mess up this text!\n"
"--------------------------------\n"
"   I have indented it\n"
"   exactly the way\n"
"   I want it\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit"
msgstr ""

#: ../../library/argparse.rst:428
msgid ""
":class:`RawTextHelpFormatter` maintains whitespace for all sorts of help "
"text, including argument descriptions. However, multiple new lines are "
"replaced with one. If you wish to preserve multiple blank lines, add "
"spaces between the newlines."
msgstr ""

#: ../../library/argparse.rst:433
msgid ""
":class:`ArgumentDefaultsHelpFormatter` automatically adds information "
"about default values to each of the argument help messages::"
msgstr ""

#: ../../library/argparse.rst:436
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int, default=42, help='FOO!')\n"
">>> parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')"
"\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo FOO] [bar [bar ...]]\n"
"\n"
"positional arguments:\n"
" bar         BAR! (default: [1, 2, 3])\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   FOO! (default: 42)"
msgstr ""

#: ../../library/argparse.rst:451
msgid ""
":class:`MetavarTypeHelpFormatter` uses the name of the type_ argument for"
" each argument as the display name for its values (rather than using the "
"dest_ as the regular formatter does)::"
msgstr ""

#: ../../library/argparse.rst:455
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.MetavarTypeHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', type=float)\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo int] float\n"
"\n"
"positional arguments:\n"
"  float\n"
"\n"
"optional arguments:\n"
"  -h, --help  show this help message and exit\n"
"  --foo int"
msgstr ""

#: ../../library/argparse.rst:472
msgid "prefix_chars"
msgstr ""

#: ../../library/argparse.rst:474
msgid ""
"Most command-line options will use ``-`` as the prefix, e.g. "
"``-f/--foo``. Parsers that need to support different or additional prefix"
" characters, e.g. for options like ``+f`` or ``/foo``, may specify them "
"using the ``prefix_chars=`` argument to the ArgumentParser constructor::"
msgstr ""

#: ../../library/argparse.rst:480
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+')\n"
">>> parser.add_argument('+f')\n"
">>> parser.add_argument('++bar')\n"
">>> parser.parse_args('+f X ++bar Y'.split())\n"
"Namespace(bar='Y', f='X')"
msgstr ""

#: ../../library/argparse.rst:486
msgid ""
"The ``prefix_chars=`` argument defaults to ``'-'``. Supplying a set of "
"characters that does not include ``-`` will cause ``-f/--foo`` options to"
" be disallowed."
msgstr ""

#: ../../library/argparse.rst:492
msgid "fromfile_prefix_chars"
msgstr ""

#: ../../library/argparse.rst:494
msgid ""
"Sometimes, for example when dealing with a particularly long argument "
"lists, it may make sense to keep the list of arguments in a file rather "
"than typing it out at the command line.  If the "
"``fromfile_prefix_chars=`` argument is given to the "
":class:`ArgumentParser` constructor, then arguments that start with any "
"of the specified characters will be treated as files, and will be "
"replaced by the arguments they contain.  For example::"
msgstr ""

#: ../../library/argparse.rst:501
msgid ""
">>> with open('args.txt', 'w') as fp:\n"
"...     fp.write('-f\\nbar')\n"
">>> parser = argparse.ArgumentParser(fromfile_prefix_chars='@')\n"
">>> parser.add_argument('-f')\n"
">>> parser.parse_args(['-f', 'foo', '@args.txt'])\n"
"Namespace(f='bar')"
msgstr ""

#: ../../library/argparse.rst:508
msgid ""
"Arguments read from a file must by default be one per line (but see also "
":meth:`~ArgumentParser.convert_arg_line_to_args`) and are treated as if "
"they were in the same place as the original file referencing argument on "
"the command line.  So in the example above, the expression ``['-f', "
"'foo', '@args.txt']`` is considered equivalent to the expression ``['-f',"
" 'foo', '-f', 'bar']``."
msgstr ""

#: ../../library/argparse.rst:514
msgid ""
"The ``fromfile_prefix_chars=`` argument defaults to ``None``, meaning "
"that arguments will never be treated as file references."
msgstr ""

#: ../../library/argparse.rst:519
msgid "argument_default"
msgstr ""

#: ../../library/argparse.rst:521
msgid ""
"Generally, argument defaults are specified either by passing a default to"
" :meth:`~ArgumentParser.add_argument` or by calling the "
":meth:`~ArgumentParser.set_defaults` methods with a specific set of name-"
"value pairs.  Sometimes however, it may be useful to specify a single "
"parser-wide default for arguments.  This can be accomplished by passing "
"the ``argument_default=`` keyword argument to :class:`ArgumentParser`.  "
"For example, to globally suppress attribute creation on "
":meth:`~ArgumentParser.parse_args` calls, we supply "
"``argument_default=SUPPRESS``::"
msgstr ""

#: ../../library/argparse.rst:530
msgid ""
">>> parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar', nargs='?')\n"
">>> parser.parse_args(['--foo', '1', 'BAR'])\n"
"Namespace(bar='BAR', foo='1')\n"
">>> parser.parse_args([])\n"
"Namespace()"
msgstr ""

#: ../../library/argparse.rst:541
msgid "allow_abbrev"
msgstr ""

#: ../../library/argparse.rst:543
msgid ""
"Normally, when you pass an argument list to the "
":meth:`~ArgumentParser.parse_args` method of an :class:`ArgumentParser`, "
"it :ref:`recognizes abbreviations <prefix-matching>` of long options."
msgstr ""

#: ../../library/argparse.rst:547
msgid "This feature can be disabled by setting ``allow_abbrev`` to ``False``::"
msgstr ""

#: ../../library/argparse.rst:549
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', allow_abbrev=False)\n"
">>> parser.add_argument('--foobar', action='store_true')\n"
">>> parser.add_argument('--foonley', action='store_false')\n"
">>> parser.parse_args(['--foon'])\n"
"usage: PROG [-h] [--foobar] [--foonley]\n"
"PROG: error: unrecognized arguments: --foon"
msgstr ""

#: ../../library/argparse.rst:560
msgid "conflict_handler"
msgstr ""

#: ../../library/argparse.rst:562
msgid ""
":class:`ArgumentParser` objects do not allow two actions with the same "
"option string.  By default, :class:`ArgumentParser` objects raise an "
"exception if an attempt is made to create an argument with an option "
"string that is already in use::"
msgstr ""

#: ../../library/argparse.rst:567
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo', help='old foo help')\n"
">>> parser.add_argument('--foo', help='new foo help')\n"
"Traceback (most recent call last):\n"
" ..\n"
"ArgumentError: argument --foo: conflicting option string(s): --foo"
msgstr ""

#: ../../library/argparse.rst:574
msgid ""
"Sometimes (e.g. when using parents_) it may be useful to simply override "
"any older arguments with the same option string.  To get this behavior, "
"the value ``'resolve'`` can be supplied to the ``conflict_handler=`` "
"argument of :class:`ArgumentParser`::"
msgstr ""

#: ../../library/argparse.rst:579
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', "
"conflict_handler='resolve')\n"
">>> parser.add_argument('-f', '--foo', help='old foo help')\n"
">>> parser.add_argument('--foo', help='new foo help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [-f FOO] [--foo FOO]\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit\n"
" -f FOO      old foo help\n"
" --foo FOO   new foo help"
msgstr ""

#: ../../library/argparse.rst:590
msgid ""
"Note that :class:`ArgumentParser` objects only remove an action if all of"
" its option strings are overridden.  So, in the example above, the old "
"``-f/--foo`` action is retained as the ``-f`` action, because only the "
"``--foo`` option string was overridden."
msgstr ""

#: ../../library/argparse.rst:597
msgid "add_help"
msgstr ""

#: ../../library/argparse.rst:599
msgid ""
"By default, ArgumentParser objects add an option which simply displays "
"the parser's help message. For example, consider a file named "
"``myprogram.py`` containing the following code::"
msgstr ""

#: ../../library/argparse.rst:608
msgid ""
"If ``-h`` or ``--help`` is supplied at the command line, the "
"ArgumentParser help will be printed:"
msgstr ""

#: ../../library/argparse.rst:611
msgid ""
"$ python myprogram.py --help\n"
"usage: myprogram.py [-h] [--foo FOO]\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   foo help"
msgstr ""

#: ../../library/argparse.rst:620
msgid ""
"Occasionally, it may be useful to disable the addition of this help "
"option. This can be achieved by passing ``False`` as the ``add_help=`` "
"argument to :class:`ArgumentParser`::"
msgstr ""

#: ../../library/argparse.rst:624
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> parser.add_argument('--foo', help='foo help')\n"
">>> parser.print_help()\n"
"usage: PROG [--foo FOO]\n"
"\n"
"optional arguments:\n"
" --foo FOO  foo help"
msgstr ""

#: ../../library/argparse.rst:632
msgid ""
"The help option is typically ``-h/--help``. The exception to this is if "
"the ``prefix_chars=`` is specified and does not include ``-``, in which "
"case ``-h`` and ``--help`` are not valid options.  In this case, the "
"first character in ``prefix_chars`` is used to prefix the help options::"
msgstr ""

#: ../../library/argparse.rst:638
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='+/')\n"
">>> parser.print_help()\n"
"usage: PROG [+h]\n"
"\n"
"optional arguments:\n"
"  +h, ++help  show this help message and exit"
msgstr ""

#: ../../library/argparse.rst:647
msgid "The add_argument() method"
msgstr ""

#: ../../library/argparse.rst:653
msgid ""
"Define how a single command-line argument should be parsed.  Each "
"parameter has its own more detailed description below, but in short they "
"are:"
msgstr ""

#: ../../library/argparse.rst:656
msgid ""
"`name or flags`_ - Either a name or a list of option strings, e.g. "
"``foo`` or ``-f, --foo``."
msgstr ""

#: ../../library/argparse.rst:659
msgid ""
"action_ - The basic type of action to be taken when this argument is "
"encountered at the command line."
msgstr ""

#: ../../library/argparse.rst:662
msgid "nargs_ - The number of command-line arguments that should be consumed."
msgstr ""

#: ../../library/argparse.rst:664
msgid "const_ - A constant value required by some action_ and nargs_ selections."
msgstr ""

#: ../../library/argparse.rst:666
msgid ""
"default_ - The value produced if the argument is absent from the command "
"line."
msgstr ""

#: ../../library/argparse.rst:669
msgid "type_ - The type to which the command-line argument should be converted."
msgstr ""

#: ../../library/argparse.rst:671
msgid "choices_ - A container of the allowable values for the argument."
msgstr ""

#: ../../library/argparse.rst:673
msgid ""
"required_ - Whether or not the command-line option may be omitted "
"(optionals only)."
msgstr ""

#: ../../library/argparse.rst:676
msgid "help_ - A brief description of what the argument does."
msgstr ""

#: ../../library/argparse.rst:678
msgid "metavar_ - A name for the argument in usage messages."
msgstr ""

#: ../../library/argparse.rst:680
msgid ""
"dest_ - The name of the attribute to be added to the object returned by "
":meth:`parse_args`."
msgstr ""

#: ../../library/argparse.rst:687
msgid "name or flags"
msgstr ""

#: ../../library/argparse.rst:689
msgid ""
"The :meth:`~ArgumentParser.add_argument` method must know whether an "
"optional argument, like ``-f`` or ``--foo``, or a positional argument, "
"like a list of filenames, is expected.  The first arguments passed to "
":meth:`~ArgumentParser.add_argument` must therefore be either a series of"
" flags, or a simple argument name.  For example, an optional argument "
"could be created like::"
msgstr ""

#: ../../library/argparse.rst:696
msgid ">>> parser.add_argument('-f', '--foo')"
msgstr ""

#: ../../library/argparse.rst:698
msgid "while a positional argument could be created like::"
msgstr ""

#: ../../library/argparse.rst:700
msgid ">>> parser.add_argument('bar')"
msgstr ""

#: ../../library/argparse.rst:702
msgid ""
"When :meth:`~ArgumentParser.parse_args` is called, optional arguments "
"will be identified by the ``-`` prefix, and the remaining arguments will "
"be assumed to be positional::"
msgstr ""

#: ../../library/argparse.rst:706
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['BAR'])\n"
"Namespace(bar='BAR', foo=None)\n"
">>> parser.parse_args(['BAR', '--foo', 'FOO'])\n"
"Namespace(bar='BAR', foo='FOO')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"usage: PROG [-h] [-f FOO] bar\n"
"PROG: error: the following arguments are required: bar"
msgstr ""

#: ../../library/argparse.rst:719
msgid "action"
msgstr ""

#: ../../library/argparse.rst:721
msgid ""
":class:`ArgumentParser` objects associate command-line arguments with "
"actions.  These actions can do just about anything with the command-line "
"arguments associated with them, though most actions simply add an "
"attribute to the object returned by :meth:`~ArgumentParser.parse_args`.  "
"The ``action`` keyword argument specifies how the command-line arguments "
"should be handled. The supplied actions are:"
msgstr ""

#: ../../library/argparse.rst:727
msgid ""
"``'store'`` - This just stores the argument's value.  This is the default"
" action. For example::"
msgstr ""

#: ../../library/argparse.rst:735
msgid ""
"``'store_const'`` - This stores the value specified by the const_ keyword"
" argument.  The ``'store_const'`` action is most commonly used with "
"optional arguments that specify some sort of flag.  For example::"
msgstr ""

#: ../../library/argparse.rst:744
msgid ""
"``'store_true'`` and ``'store_false'`` - These are special cases of "
"``'store_const'`` used for storing the values ``True`` and ``False`` "
"respectively.  In addition, they create default values of ``False`` and "
"``True`` respectively.  For example::"
msgstr ""

#: ../../library/argparse.rst:756
msgid ""
"``'append'`` - This stores a list, and appends each argument value to the"
" list.  This is useful to allow an option to be specified multiple times."
" Example usage::"
msgstr ""

#: ../../library/argparse.rst:765
msgid ""
"``'append_const'`` - This stores a list, and appends the value specified "
"by the const_ keyword argument to the list.  (Note that the const_ "
"keyword argument defaults to ``None``.)  The ``'append_const'`` action is"
" typically useful when multiple arguments need to store constants to the "
"same list. For example::"
msgstr ""

#: ../../library/argparse.rst:777
msgid ""
"``'count'`` - This counts the number of times a keyword argument occurs. "
"For example, this is useful for increasing verbosity levels::"
msgstr ""

#: ../../library/argparse.rst:785
msgid ""
"``'help'`` - This prints a complete help message for all the options in "
"the current parser and then exits. By default a help action is "
"automatically added to the parser. See :class:`ArgumentParser` for "
"details of how the output is created."
msgstr ""

#: ../../library/argparse.rst:790
msgid ""
"``'version'`` - This expects a ``version=`` keyword argument in the "
":meth:`~ArgumentParser.add_argument` call, and prints version information"
" and exits when invoked::"
msgstr ""

#: ../../library/argparse.rst:800
msgid ""
"You may also specify an arbitrary action by passing an Action subclass or"
" other object that implements the same interface.  The recommended way to"
" do this is to extend :class:`Action`, overriding the ``__call__`` method"
" and optionally the ``__init__`` method."
msgstr ""

#: ../../library/argparse.rst:805
msgid "An example of a custom action::"
msgstr ""

#: ../../library/argparse.rst:807
#, python-format
msgid ""
">>> class FooAction(argparse.Action):\n"
"...     def __init__(self, option_strings, dest, nargs=None, **kwargs):\n"
"...         if nargs is not None:\n"
"...             raise ValueError(\"nargs not allowed\")\n"
"...         super(FooAction, self).__init__(option_strings, dest, "
"**kwargs)\n"
"...     def __call__(self, parser, namespace, values, "
"option_string=None):\n"
"...         print('%r %r %r' % (namespace, values, option_string))\n"
"...         setattr(namespace, self.dest, values)\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=FooAction)\n"
">>> parser.add_argument('bar', action=FooAction)\n"
">>> args = parser.parse_args('1 --foo 2'.split())\n"
"Namespace(bar=None, foo=None) '1' None\n"
"Namespace(bar='1', foo=None) '2' '--foo'\n"
">>> args\n"
"Namespace(bar='1', foo='2')"
msgstr ""

#: ../../library/argparse.rst:825
msgid "For more details, see :class:`Action`."
msgstr ""

#: ../../library/argparse.rst:828
msgid "nargs"
msgstr ""

#: ../../library/argparse.rst:830
msgid ""
"ArgumentParser objects usually associate a single command-line argument "
"with a single action to be taken.  The ``nargs`` keyword argument "
"associates a different number of command-line arguments with a single "
"action.  The supported values are:"
msgstr ""

#: ../../library/argparse.rst:835
msgid ""
"``N`` (an integer).  ``N`` arguments from the command line will be "
"gathered together into a list.  For example::"
msgstr ""

#: ../../library/argparse.rst:844
msgid ""
"Note that ``nargs=1`` produces a list of one item.  This is different "
"from the default, in which the item is produced by itself."
msgstr ""

#: ../../library/argparse.rst:847
msgid ""
"``'?'``. One argument will be consumed from the command line if possible,"
" and produced as a single item.  If no command-line argument is present, "
"the value from default_ will be produced.  Note that for optional "
"arguments, there is an additional case - the option string is present but"
" not followed by a command-line argument.  In this case the value from "
"const_ will be produced.  Some examples to illustrate this::"
msgstr ""

#: ../../library/argparse.rst:864
msgid ""
"One of the more common uses of ``nargs='?'`` is to allow optional input "
"and output files::"
msgstr ""

#: ../../library/argparse.rst:879
msgid ""
"``'*'``.  All command-line arguments present are gathered into a list.  "
"Note that it generally doesn't make much sense to have more than one "
"positional argument with ``nargs='*'``, but multiple optional arguments "
"with ``nargs='*'`` is possible.  For example::"
msgstr ""

#: ../../library/argparse.rst:891
msgid ""
"``'+'``. Just like ``'*'``, all command-line args present are gathered "
"into a list.  Additionally, an error message will be generated if there "
"wasn't at least one command-line argument present.  For example::"
msgstr ""

#: ../../library/argparse.rst:905
msgid ""
"``argparse.REMAINDER``.  All the remaining command-line arguments are "
"gathered into a list.  This is commonly useful for command line utilities"
" that dispatch to other command line utilities::"
msgstr ""

#: ../../library/argparse.rst:916
msgid ""
"If the ``nargs`` keyword argument is not provided, the number of "
"arguments consumed is determined by the action_.  Generally this means a "
"single command-line argument will be consumed and a single item (not a "
"list) will be produced."
msgstr ""

#: ../../library/argparse.rst:922
msgid "const"
msgstr ""

#: ../../library/argparse.rst:924
msgid ""
"The ``const`` argument of :meth:`~ArgumentParser.add_argument` is used to"
" hold constant values that are not read from the command line but are "
"required for the various :class:`ArgumentParser` actions.  The two most "
"common uses of it are:"
msgstr ""

#: ../../library/argparse.rst:928
msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with "
"``action='store_const'`` or ``action='append_const'``.  These actions add"
" the ``const`` value to one of the attributes of the object returned by "
":meth:`~ArgumentParser.parse_args`. See the action_ description for "
"examples."
msgstr ""

#: ../../library/argparse.rst:933
msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with option strings "
"(like ``-f`` or ``--foo``) and ``nargs='?'``.  This creates an optional "
"argument that can be followed by zero or one command-line arguments. When"
" parsing the command line, if the option string is encountered with no "
"command-line argument following it, the value of ``const`` will be "
"assumed instead. See the nargs_ description for examples."
msgstr ""

#: ../../library/argparse.rst:940
msgid ""
"With the ``'store_const'`` and ``'append_const'`` actions, the ``const`` "
"keyword argument must be given.  For other actions, it defaults to "
"``None``."
msgstr ""

#: ../../library/argparse.rst:945
msgid "default"
msgstr ""

#: ../../library/argparse.rst:947
msgid ""
"All optional arguments and some positional arguments may be omitted at "
"the command line.  The ``default`` keyword argument of "
":meth:`~ArgumentParser.add_argument`, whose value defaults to ``None``, "
"specifies what value should be used if the command-line argument is not "
"present. For optional arguments, the ``default`` value is used when the "
"option string was not present at the command line::"
msgstr ""

#: ../../library/argparse.rst:954
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args(['--foo', '2'])\n"
"Namespace(foo='2')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"
msgstr ""

#: ../../library/argparse.rst:961
msgid ""
"If the ``default`` value is a string, the parser parses the value as if "
"it were a command-line argument.  In particular, the parser applies any "
"type_ conversion argument, if provided, before setting the attribute on "
"the :class:`Namespace` return value.  Otherwise, the parser uses the "
"value as is::"
msgstr ""

#: ../../library/argparse.rst:966
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--length', default='10', type=int)\n"
">>> parser.add_argument('--width', default=10.5, type=int)\n"
">>> parser.parse_args()\n"
"Namespace(length=10, width=10.5)"
msgstr ""

#: ../../library/argparse.rst:972
msgid ""
"For positional arguments with nargs_ equal to ``?`` or ``*``, the "
"``default`` value is used when no command-line argument was present::"
msgstr ""

#: ../../library/argparse.rst:975
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', nargs='?', default=42)\n"
">>> parser.parse_args(['a'])\n"
"Namespace(foo='a')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"
msgstr ""

#: ../../library/argparse.rst:983
msgid ""
"Providing ``default=argparse.SUPPRESS`` causes no attribute to be added "
"if the command-line argument was not present.::"
msgstr ""

#: ../../library/argparse.rst:986
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=argparse.SUPPRESS)\n"
">>> parser.parse_args([])\n"
"Namespace()\n"
">>> parser.parse_args(['--foo', '1'])\n"
"Namespace(foo='1')"
msgstr ""

#: ../../library/argparse.rst:995
msgid "type"
msgstr ""

#: ../../library/argparse.rst:997
msgid ""
"By default, :class:`ArgumentParser` objects read command-line arguments "
"in as simple strings. However, quite often the command-line string should"
" instead be interpreted as another type, like a :class:`float` or "
":class:`int`.  The ``type`` keyword argument of "
":meth:`~ArgumentParser.add_argument` allows any necessary type-checking "
"and type conversions to be performed.  Common built-in types and "
"functions can be used directly as the value of the ``type`` argument::"
msgstr ""

#: ../../library/argparse.rst:1004
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', type=int)\n"
">>> parser.add_argument('bar', type=open)\n"
">>> parser.parse_args('2 temp.txt'.split())\n"
"Namespace(bar=<_io.TextIOWrapper name='temp.txt' encoding='UTF-8'>, foo=2)"
msgstr ""

#: ../../library/argparse.rst:1010
msgid ""
"See the section on the default_ keyword argument for information on when "
"the ``type`` argument is applied to default arguments."
msgstr ""

#: ../../library/argparse.rst:1013
msgid ""
"To ease the use of various types of files, the argparse module provides "
"the factory FileType which takes the ``mode=``, ``bufsize=``, "
"``encoding=`` and ``errors=`` arguments of the :func:`open` function.  "
"For example, ``FileType('w')`` can be used to create a writable file::"
msgstr ""

#: ../../library/argparse.rst:1018
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('bar', type=argparse.FileType('w'))\n"
">>> parser.parse_args(['out.txt'])\n"
"Namespace(bar=<_io.TextIOWrapper name='out.txt' encoding='UTF-8'>)"
msgstr ""

#: ../../library/argparse.rst:1023
msgid ""
"``type=`` can take any callable that takes a single string argument and "
"returns the converted value::"
msgstr ""

#: ../../library/argparse.rst:1026
#, python-format
msgid ""
">>> def perfect_square(string):\n"
"...     value = int(string)\n"
"...     sqrt = math.sqrt(value)\n"
"...     if sqrt != int(sqrt):\n"
"...         msg = \"%r is not a perfect square\" % string\n"
"...         raise argparse.ArgumentTypeError(msg)\n"
"...     return value\n"
"...\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('foo', type=perfect_square)\n"
">>> parser.parse_args(['9'])\n"
"Namespace(foo=9)\n"
">>> parser.parse_args(['7'])\n"
"usage: PROG [-h] foo\n"
"PROG: error: argument foo: '7' is not a perfect square"
msgstr ""

#: ../../library/argparse.rst:1042
msgid ""
"The choices_ keyword argument may be more convenient for type checkers "
"that simply check against a range of values::"
msgstr ""

#: ../../library/argparse.rst:1045
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('foo', type=int, choices=range(5, 10))\n"
">>> parser.parse_args(['7'])\n"
"Namespace(foo=7)\n"
">>> parser.parse_args(['11'])\n"
"usage: PROG [-h] {5,6,7,8,9}\n"
"PROG: error: argument foo: invalid choice: 11 (choose from 5, 6, 7, 8, 9)"
msgstr ""

#: ../../library/argparse.rst:1053
msgid "See the choices_ section for more details."
msgstr ""

#: ../../library/argparse.rst:1057
msgid "choices"
msgstr ""

#: ../../library/argparse.rst:1059
msgid ""
"Some command-line arguments should be selected from a restricted set of "
"values. These can be handled by passing a container object as the "
"*choices* keyword argument to :meth:`~ArgumentParser.add_argument`.  When"
" the command line is parsed, argument values will be checked, and an "
"error message will be displayed if the argument was not one of the "
"acceptable values::"
msgstr ""

#: ../../library/argparse.rst:1065
msgid ""
">>> parser = argparse.ArgumentParser(prog='game.py')\n"
">>> parser.add_argument('move', choices=['rock', 'paper', 'scissors'])\n"
">>> parser.parse_args(['rock'])\n"
"Namespace(move='rock')\n"
">>> parser.parse_args(['fire'])\n"
"usage: game.py [-h] {rock,paper,scissors}\n"
"game.py: error: argument move: invalid choice: 'fire' (choose from "
"'rock',\n"
"'paper', 'scissors')"
msgstr ""

#: ../../library/argparse.rst:1074
msgid ""
"Note that inclusion in the *choices* container is checked after any type_"
" conversions have been performed, so the type of the objects in the "
"*choices* container should match the type_ specified::"
msgstr ""

#: ../../library/argparse.rst:1078
msgid ""
">>> parser = argparse.ArgumentParser(prog='doors.py')\n"
">>> parser.add_argument('door', type=int, choices=range(1, 4))\n"
">>> print(parser.parse_args(['3']))\n"
"Namespace(door=3)\n"
">>> parser.parse_args(['4'])\n"
"usage: doors.py [-h] {1,2,3}\n"
"doors.py: error: argument door: invalid choice: 4 (choose from 1, 2, 3)"
msgstr ""

#: ../../library/argparse.rst:1086
msgid ""
"Any object that supports the ``in`` operator can be passed as the "
"*choices* value, so :class:`dict` objects, :class:`set` objects, custom "
"containers, etc. are all supported."
msgstr ""

#: ../../library/argparse.rst:1092
msgid "required"
msgstr ""

#: ../../library/argparse.rst:1094
msgid ""
"In general, the :mod:`argparse` module assumes that flags like ``-f`` and"
" ``--bar`` indicate *optional* arguments, which can always be omitted at "
"the command line. To make an option *required*, ``True`` can be specified"
" for the ``required=`` keyword argument to "
":meth:`~ArgumentParser.add_argument`::"
msgstr ""

#: ../../library/argparse.rst:1099
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', required=True)\n"
">>> parser.parse_args(['--foo', 'BAR'])\n"
"Namespace(foo='BAR')\n"
">>> parser.parse_args([])\n"
"usage: argparse.py [-h] [--foo FOO]\n"
"argparse.py: error: option --foo is required"
msgstr ""

#: ../../library/argparse.rst:1107
msgid ""
"As the example shows, if an option is marked as ``required``, "
":meth:`~ArgumentParser.parse_args` will report an error if that option is"
" not present at the command line."
msgstr ""

#: ../../library/argparse.rst:1113
msgid ""
"Required options are generally considered bad form because users expect "
"*options* to be *optional*, and thus they should be avoided when "
"possible."
msgstr ""

#: ../../library/argparse.rst:1118
msgid "help"
msgstr ""

#: ../../library/argparse.rst:1120
msgid ""
"The ``help`` value is a string containing a brief description of the "
"argument. When a user requests help (usually by using ``-h`` or "
"``--help`` at the command line), these ``help`` descriptions will be "
"displayed with each argument::"
msgstr ""

#: ../../library/argparse.rst:1125
msgid ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('--foo', action='store_true',\n"
"...                     help='foo the bars before frobbling')\n"
">>> parser.add_argument('bar', nargs='+',\n"
"...                     help='one of the bars to be frobbled')\n"
">>> parser.parse_args(['-h'])\n"
"usage: frobble [-h] [--foo] bar [bar ...]\n"
"\n"
"positional arguments:\n"
" bar     one of the bars to be frobbled\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit\n"
" --foo   foo the bars before frobbling"
msgstr ""

#: ../../library/argparse.rst:1140
#, python-format
msgid ""
"The ``help`` strings can include various format specifiers to avoid "
"repetition of things like the program name or the argument default_.  The"
" available specifiers include the program name, ``%(prog)s`` and most "
"keyword arguments to :meth:`~ArgumentParser.add_argument`, e.g. "
"``%(default)s``, ``%(type)s``, etc.::"
msgstr ""

#: ../../library/argparse.rst:1145
#, python-format
msgid ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('bar', nargs='?', type=int, default=42,\n"
"...                     help='the bar to %(prog)s (default: "
"%(default)s)')\n"
">>> parser.print_help()\n"
"usage: frobble [-h] [bar]\n"
"\n"
"positional arguments:\n"
" bar     the bar to frobble (default: 42)\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit"
msgstr ""

#: ../../library/argparse.rst:1157
#, python-format
msgid ""
"As the help string supports %-formatting, if you want a literal ``%`` to "
"appear in the help string, you must escape it as ``%%``."
msgstr ""

#: ../../library/argparse.rst:1160
msgid ""
":mod:`argparse` supports silencing the help entry for certain options, by"
" setting the ``help`` value to ``argparse.SUPPRESS``::"
msgstr ""

#: ../../library/argparse.rst:1163
msgid ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('--foo', help=argparse.SUPPRESS)\n"
">>> parser.print_help()\n"
"usage: frobble [-h]\n"
"\n"
"optional arguments:\n"
"  -h, --help  show this help message and exit"
msgstr ""

#: ../../library/argparse.rst:1173
msgid "metavar"
msgstr ""

#: ../../library/argparse.rst:1175
msgid ""
"When :class:`ArgumentParser` generates help messages, it needs some way "
"to refer to each expected argument.  By default, ArgumentParser objects "
"use the dest_ value as the \"name\" of each object.  By default, for "
"positional argument actions, the dest_ value is used directly, and for "
"optional argument actions, the dest_ value is uppercased.  So, a single "
"positional argument with ``dest='bar'`` will be referred to as ``bar``. A"
" single optional argument ``--foo`` that should be followed by a single "
"command-line argument will be referred to as ``FOO``.  An example::"
msgstr ""

#: ../../library/argparse.rst:1184
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo FOO] bar\n"
"\n"
"positional arguments:\n"
" bar\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO"
msgstr ""

#: ../../library/argparse.rst:1199
msgid "An alternative name can be specified with ``metavar``::"
msgstr ""

#: ../../library/argparse.rst:1201
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', metavar='YYY')\n"
">>> parser.add_argument('bar', metavar='XXX')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo YYY] XXX\n"
"\n"
"positional arguments:\n"
" XXX\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit\n"
" --foo YYY"
msgstr ""

#: ../../library/argparse.rst:1216
msgid ""
"Note that ``metavar`` only changes the *displayed* name - the name of the"
" attribute on the :meth:`~ArgumentParser.parse_args` object is still "
"determined by the dest_ value."
msgstr ""

#: ../../library/argparse.rst:1220
msgid ""
"Different values of ``nargs`` may cause the metavar to be used multiple "
"times. Providing a tuple to ``metavar`` specifies a different display for"
" each of the arguments::"
msgstr ""

#: ../../library/argparse.rst:1224
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', nargs=2)\n"
">>> parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz'))\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [-x X X] [--foo bar baz]\n"
"\n"
"optional arguments:\n"
" -h, --help     show this help message and exit\n"
" -x X X\n"
" --foo bar baz"
msgstr ""

#: ../../library/argparse.rst:1237
msgid "dest"
msgstr ""

#: ../../library/argparse.rst:1239
msgid ""
"Most :class:`ArgumentParser` actions add some value as an attribute of "
"the object returned by :meth:`~ArgumentParser.parse_args`.  The name of "
"this attribute is determined by the ``dest`` keyword argument of "
":meth:`~ArgumentParser.add_argument`.  For positional argument actions, "
"``dest`` is normally supplied as the first argument to "
":meth:`~ArgumentParser.add_argument`::"
msgstr ""

#: ../../library/argparse.rst:1246
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['XXX'])\n"
"Namespace(bar='XXX')"
msgstr ""

#: ../../library/argparse.rst:1251
msgid ""
"For optional argument actions, the value of ``dest`` is normally inferred"
" from the option strings.  :class:`ArgumentParser` generates the value of"
" ``dest`` by taking the first long option string and stripping away the "
"initial ``--`` string.  If no long option strings were supplied, ``dest``"
" will be derived from the first short option string by stripping the "
"initial ``-`` character.  Any internal ``-`` characters will be converted"
" to ``_`` characters to make sure the string is a valid attribute name.  "
"The examples below illustrate this behavior::"
msgstr ""

#: ../../library/argparse.rst:1260
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('-f', '--foo-bar', '--foo')\n"
">>> parser.add_argument('-x', '-y')\n"
">>> parser.parse_args('-f 1 -x 2'.split())\n"
"Namespace(foo_bar='1', x='2')\n"
">>> parser.parse_args('--foo 1 -y 2'.split())\n"
"Namespace(foo_bar='1', x='2')"
msgstr ""

#: ../../library/argparse.rst:1268
msgid "``dest`` allows a custom attribute name to be provided::"
msgstr ""

#: ../../library/argparse.rst:1270
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', dest='bar')\n"
">>> parser.parse_args('--foo XXX'.split())\n"
"Namespace(bar='XXX')"
msgstr ""

#: ../../library/argparse.rst:1276
msgid "Action classes"
msgstr ""

#: ../../library/argparse.rst:1278
msgid ""
"Action classes implement the Action API, a callable which returns a "
"callable which processes arguments from the command-line. Any object "
"which follows this API may be passed as the ``action`` parameter to "
":meth:`add_argument`."
msgstr ""

#: ../../library/argparse.rst:1287
msgid ""
"Action objects are used by an ArgumentParser to represent the information"
" needed to parse a single argument from one or more strings from the "
"command line. The Action class must accept the two positional arguments "
"plus any keyword arguments passed to :meth:`ArgumentParser.add_argument` "
"except for the ``action`` itself."
msgstr ""

#: ../../library/argparse.rst:1293
msgid ""
"Instances of Action (or return value of any callable to the ``action`` "
"parameter) should have attributes \"dest\", \"option_strings\", "
"\"default\", \"type\", \"required\", \"help\", etc. defined. The easiest "
"way to ensure these attributes are defined is to call "
"``Action.__init__``."
msgstr ""

#: ../../library/argparse.rst:1298
msgid ""
"Action instances should be callable, so subclasses must override the "
"``__call__`` method, which should accept four parameters:"
msgstr ""

#: ../../library/argparse.rst:1301
msgid "``parser`` - The ArgumentParser object which contains this action."
msgstr ""

#: ../../library/argparse.rst:1303
msgid ""
"``namespace`` - The :class:`Namespace` object that will be returned by "
":meth:`~ArgumentParser.parse_args`.  Most actions add an attribute to "
"this object using :func:`setattr`."
msgstr ""

#: ../../library/argparse.rst:1307
msgid ""
"``values`` - The associated command-line arguments, with any type "
"conversions applied.  Type conversions are specified with the type_ "
"keyword argument to :meth:`~ArgumentParser.add_argument`."
msgstr ""

#: ../../library/argparse.rst:1311
msgid ""
"``option_string`` - The option string that was used to invoke this "
"action. The ``option_string`` argument is optional, and will be absent if"
" the action is associated with a positional argument."
msgstr ""

#: ../../library/argparse.rst:1315
msgid ""
"The ``__call__`` method may perform arbitrary actions, but will typically"
" set attributes on the ``namespace`` based on ``dest`` and ``values``."
msgstr ""

#: ../../library/argparse.rst:1320
msgid "The parse_args() method"
msgstr ""

#: ../../library/argparse.rst:1324
msgid ""
"Convert argument strings to objects and assign them as attributes of the "
"namespace.  Return the populated namespace."
msgstr ""

#: ../../library/argparse.rst:1327
msgid ""
"Previous calls to :meth:`add_argument` determine exactly what objects are"
" created and how they are assigned. See the documentation for "
":meth:`add_argument` for details."
msgstr ""

#: ../../library/argparse.rst:1331
msgid ""
"args_ - List of strings to parse.  The default is taken from "
":data:`sys.argv`."
msgstr ""

#: ../../library/argparse.rst:1334
msgid ""
"namespace_ - An object to take the attributes.  The default is a new "
"empty :class:`Namespace` object."
msgstr ""

#: ../../library/argparse.rst:1339
msgid "Option value syntax"
msgstr ""

#: ../../library/argparse.rst:1341
msgid ""
"The :meth:`~ArgumentParser.parse_args` method supports several ways of "
"specifying the value of an option (if it takes one).  In the simplest "
"case, the option and its value are passed as two separate arguments::"
msgstr ""

#: ../../library/argparse.rst:1345
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(['-x', 'X'])\n"
"Namespace(foo=None, x='X')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"Namespace(foo='FOO', x=None)"
msgstr ""

#: ../../library/argparse.rst:1353
msgid ""
"For long options (options with names longer than a single character), the"
" option and value can also be passed as a single command-line argument, "
"using ``=`` to separate them::"
msgstr ""

#: ../../library/argparse.rst:1357
msgid ""
">>> parser.parse_args(['--foo=FOO'])\n"
"Namespace(foo='FOO', x=None)"
msgstr ""

#: ../../library/argparse.rst:1360
msgid ""
"For short options (options only one character long), the option and its "
"value can be concatenated::"
msgstr ""

#: ../../library/argparse.rst:1363
msgid ""
">>> parser.parse_args(['-xX'])\n"
"Namespace(foo=None, x='X')"
msgstr ""

#: ../../library/argparse.rst:1366
msgid ""
"Several short options can be joined together, using only a single ``-`` "
"prefix, as long as only the last option (or none of them) requires a "
"value::"
msgstr ""

#: ../../library/argparse.rst:1369
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', action='store_true')\n"
">>> parser.add_argument('-y', action='store_true')\n"
">>> parser.add_argument('-z')\n"
">>> parser.parse_args(['-xyzZ'])\n"
"Namespace(x=True, y=True, z='Z')"
msgstr ""

#: ../../library/argparse.rst:1378
msgid "Invalid arguments"
msgstr ""

#: ../../library/argparse.rst:1380
msgid ""
"While parsing the command line, :meth:`~ArgumentParser.parse_args` checks"
" for a variety of errors, including ambiguous options, invalid types, "
"invalid options, wrong number of positional arguments, etc.  When it "
"encounters such an error, it exits and prints the error along with a "
"usage message::"
msgstr ""

#: ../../library/argparse.rst:1385
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', nargs='?')\n"
"\n"
">>> # invalid type\n"
">>> parser.parse_args(['--foo', 'spam'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: argument --foo: invalid int value: 'spam'\n"
"\n"
">>> # invalid option\n"
">>> parser.parse_args(['--bar'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: no such option: --bar\n"
"\n"
">>> # wrong number of arguments\n"
">>> parser.parse_args(['spam', 'badger'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: extra arguments found: badger"
msgstr ""

#: ../../library/argparse.rst:1406
msgid "Arguments containing ``-``"
msgstr ""

#: ../../library/argparse.rst:1408
msgid ""
"The :meth:`~ArgumentParser.parse_args` method attempts to give errors "
"whenever the user has clearly made a mistake, but some situations are "
"inherently ambiguous.  For example, the command-line argument ``-1`` "
"could either be an attempt to specify an option or an attempt to provide "
"a positional argument. The :meth:`~ArgumentParser.parse_args` method is "
"cautious here: positional arguments may only begin with ``-`` if they "
"look like negative numbers and there are no options in the parser that "
"look like negative numbers::"
msgstr ""

#: ../../library/argparse.rst:1416
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # no negative number options, so -1 is a positional argument\n"
">>> parser.parse_args(['-x', '-1'])\n"
"Namespace(foo=None, x='-1')\n"
"\n"
">>> # no negative number options, so -1 and -5 are positional arguments\n"
">>> parser.parse_args(['-x', '-1', '-5'])\n"
"Namespace(foo='-5', x='-1')\n"
"\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-1', dest='one')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # negative number options present, so -1 is an option\n"
">>> parser.parse_args(['-1', 'X'])\n"
"Namespace(foo=None, one='X')\n"
"\n"
">>> # negative number options present, so -2 is an option\n"
">>> parser.parse_args(['-2'])\n"
"usage: PROG [-h] [-1 ONE] [foo]\n"
"PROG: error: no such option: -2\n"
"\n"
">>> # negative number options present, so both -1s are options\n"
">>> parser.parse_args(['-1', '-1'])\n"
"usage: PROG [-h] [-1 ONE] [foo]\n"
"PROG: error: argument -1: expected one argument"
msgstr ""

#: ../../library/argparse.rst:1446
msgid ""
"If you have positional arguments that must begin with ``-`` and don't "
"look like negative numbers, you can insert the pseudo-argument ``'--'`` "
"which tells :meth:`~ArgumentParser.parse_args` that everything after that"
" is a positional argument::"
msgstr ""

#: ../../library/argparse.rst:1451
msgid ""
">>> parser.parse_args(['--', '-f'])\n"
"Namespace(foo='-f', one=None)"
msgstr ""

#: ../../library/argparse.rst:1457
msgid "Argument abbreviations (prefix matching)"
msgstr ""

#: ../../library/argparse.rst:1459
msgid ""
"The :meth:`~ArgumentParser.parse_args` method :ref:`by default "
"<allow_abbrev>` allows long options to be abbreviated to a prefix, if the"
" abbreviation is unambiguous (the prefix matches a unique option)::"
msgstr ""

#: ../../library/argparse.rst:1463
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-bacon')\n"
">>> parser.add_argument('-badger')\n"
">>> parser.parse_args('-bac MMM'.split())\n"
"Namespace(bacon='MMM', badger=None)\n"
">>> parser.parse_args('-bad WOOD'.split())\n"
"Namespace(bacon=None, badger='WOOD')\n"
">>> parser.parse_args('-ba BA'.split())\n"
"usage: PROG [-h] [-bacon BACON] [-badger BADGER]\n"
"PROG: error: ambiguous option: -ba could match -badger, -bacon"
msgstr ""

#: ../../library/argparse.rst:1474
msgid ""
"An error is produced for arguments that could produce more than one "
"options. This feature can be disabled by setting :ref:`allow_abbrev` to "
"``False``."
msgstr ""

#: ../../library/argparse.rst:1480
msgid "Beyond ``sys.argv``"
msgstr ""

#: ../../library/argparse.rst:1482
msgid ""
"Sometimes it may be useful to have an ArgumentParser parse arguments "
"other than those of :data:`sys.argv`.  This can be accomplished by "
"passing a list of strings to :meth:`~ArgumentParser.parse_args`.  This is"
" useful for testing at the interactive prompt::"
msgstr ""

#: ../../library/argparse.rst:1487
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\n"
"...     'integers', metavar='int', type=int, choices=range(10),\n"
"...     nargs='+', help='an integer in the range 0..9')\n"
">>> parser.add_argument(\n"
"...     '--sum', dest='accumulate', action='store_const', const=sum,\n"
"...     default=max, help='sum the integers (default: find the max)')\n"
">>> parser.parse_args(['1', '2', '3', '4'])\n"
"Namespace(accumulate=<built-in function max>, integers=[1, 2, 3, 4])\n"
">>> parser.parse_args(['1', '2', '3', '4', '--sum'])\n"
"Namespace(accumulate=<built-in function sum>, integers=[1, 2, 3, 4])"
msgstr ""

#: ../../library/argparse.rst:1502
msgid "The Namespace object"
msgstr ""

#: ../../library/argparse.rst:1506
msgid ""
"Simple class used by default by :meth:`~ArgumentParser.parse_args` to "
"create an object holding attributes and return it."
msgstr ""

#: ../../library/argparse.rst:1509
msgid ""
"This class is deliberately simple, just an :class:`object` subclass with "
"a readable string representation. If you prefer to have dict-like view of"
" the attributes, you can use the standard Python idiom, :func:`vars`::"
msgstr ""

#: ../../library/argparse.rst:1513
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> args = parser.parse_args(['--foo', 'BAR'])\n"
">>> vars(args)\n"
"{'foo': 'BAR'}"
msgstr ""

#: ../../library/argparse.rst:1519
msgid ""
"It may also be useful to have an :class:`ArgumentParser` assign "
"attributes to an already existing object, rather than a new "
":class:`Namespace` object.  This can be achieved by specifying the "
"``namespace=`` keyword argument::"
msgstr ""

#: ../../library/argparse.rst:1523
msgid ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(args=['--foo', 'BAR'], namespace=c)\n"
">>> c.foo\n"
"'BAR'"
msgstr ""

#: ../../library/argparse.rst:1535
msgid "Other utilities"
msgstr ""

#: ../../library/argparse.rst:1538
msgid "Sub-commands"
msgstr ""

#: ../../library/argparse.rst:1545
msgid ""
"Many programs split up their functionality into a number of sub-commands,"
" for example, the ``svn`` program can invoke sub-commands like ``svn "
"checkout``, ``svn update``, and ``svn commit``.  Splitting up "
"functionality this way can be a particularly good idea when a program "
"performs several different functions which require different kinds of "
"command-line arguments. :class:`ArgumentParser` supports the creation of "
"such sub-commands with the :meth:`add_subparsers` method.  The "
":meth:`add_subparsers` method is normally called with no arguments and "
"returns a special action object.  This object has a single method, "
":meth:`~ArgumentParser.add_parser`, which takes a command name and any "
":class:`ArgumentParser` constructor arguments, and returns an "
":class:`ArgumentParser` object that can be modified as usual."
msgstr ""

#: ../../library/argparse.rst:1557
msgid "Description of parameters:"
msgstr ""

#: ../../library/argparse.rst:1559
msgid ""
"title - title for the sub-parser group in help output; by default "
"\"subcommands\" if description is provided, otherwise uses title for "
"positional arguments"
msgstr ""

#: ../../library/argparse.rst:1563
msgid ""
"description - description for the sub-parser group in help output, by "
"default ``None``"
msgstr ""

#: ../../library/argparse.rst:1566
msgid ""
"prog - usage information that will be displayed with sub-command help, by"
" default the name of the program and any positional arguments before the "
"subparser argument"
msgstr ""

#: ../../library/argparse.rst:1570
msgid ""
"parser_class - class which will be used to create sub-parser instances, "
"by default the class of the current parser (e.g. ArgumentParser)"
msgstr ""

#: ../../library/argparse.rst:1573
msgid ""
"action_ - the basic type of action to be taken when this argument is "
"encountered at the command line"
msgstr ""

#: ../../library/argparse.rst:1576
msgid ""
"dest_ - name of the attribute under which sub-command name will be "
"stored; by default ``None`` and no value is stored"
msgstr ""

#: ../../library/argparse.rst:1579
msgid "help_ - help for sub-parser group in help output, by default ``None``"
msgstr ""

#: ../../library/argparse.rst:1581
msgid ""
"metavar_ - string presenting available sub-commands in help; by default "
"it is ``None`` and presents sub-commands in form {cmd1, cmd2, ..}"
msgstr ""

#: ../../library/argparse.rst:1584
msgid "Some example usage::"
msgstr ""

#: ../../library/argparse.rst:1586
msgid ""
">>> # create the top-level parser\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', action='store_true', help='foo help')\n"
">>> subparsers = parser.add_subparsers(help='sub-command help')\n"
">>>\n"
">>> # create the parser for the \"a\" command\n"
">>> parser_a = subparsers.add_parser('a', help='a help')\n"
">>> parser_a.add_argument('bar', type=int, help='bar help')\n"
">>>\n"
">>> # create the parser for the \"b\" command\n"
">>> parser_b = subparsers.add_parser('b', help='b help')\n"
">>> parser_b.add_argument('--baz', choices='XYZ', help='baz help')\n"
">>>\n"
">>> # parse some argument lists\n"
">>> parser.parse_args(['a', '12'])\n"
"Namespace(bar=12, foo=False)\n"
">>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])\n"
"Namespace(baz='Z', foo=True)"
msgstr ""

#: ../../library/argparse.rst:1605
msgid ""
"Note that the object returned by :meth:`parse_args` will only contain "
"attributes for the main parser and the subparser that was selected by the"
" command line (and not any other subparsers).  So in the example above, "
"when the ``a`` command is specified, only the ``foo`` and ``bar`` "
"attributes are present, and when the ``b`` command is specified, only the"
" ``foo`` and ``baz`` attributes are present."
msgstr ""

#: ../../library/argparse.rst:1612
msgid ""
"Similarly, when a help message is requested from a subparser, only the "
"help for that particular parser will be printed.  The help message will "
"not include parent parser or sibling parser messages.  (A help message "
"for each subparser command, however, can be given by supplying the "
"``help=`` argument to :meth:`add_parser` as above.)"
msgstr ""

#: ../../library/argparse.rst:1620
msgid ""
">>> parser.parse_args(['--help'])\n"
"usage: PROG [-h] [--foo] {a,b} ...\n"
"\n"
"positional arguments:\n"
"  {a,b}   sub-command help\n"
"    a     a help\n"
"    b     b help\n"
"\n"
"optional arguments:\n"
"  -h, --help  show this help message and exit\n"
"  --foo   foo help\n"
"\n"
">>> parser.parse_args(['a', '--help'])\n"
"usage: PROG a [-h] bar\n"
"\n"
"positional arguments:\n"
"  bar     bar help\n"
"\n"
"optional arguments:\n"
"  -h, --help  show this help message and exit\n"
"\n"
">>> parser.parse_args(['b', '--help'])\n"
"usage: PROG b [-h] [--baz {X,Y,Z}]\n"
"\n"
"optional arguments:\n"
"  -h, --help     show this help message and exit\n"
"  --baz {X,Y,Z}  baz help"
msgstr ""

#: ../../library/argparse.rst:1648
msgid ""
"The :meth:`add_subparsers` method also supports ``title`` and "
"``description`` keyword arguments.  When either is present, the "
"subparser's commands will appear in their own group in the help output.  "
"For example::"
msgstr ""

#: ../../library/argparse.rst:1652
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(title='subcommands',\n"
"...                                    description='valid subcommands',\n"
"...                                    help='additional help')\n"
">>> subparsers.add_parser('foo')\n"
">>> subparsers.add_parser('bar')\n"
">>> parser.parse_args(['-h'])\n"
"usage:  [-h] {foo,bar} ...\n"
"\n"
"optional arguments:\n"
"  -h, --help  show this help message and exit\n"
"\n"
"subcommands:\n"
"  valid subcommands\n"
"\n"
"  {foo,bar}   additional help"
msgstr ""

#: ../../library/argparse.rst:1669
msgid ""
"Furthermore, ``add_parser`` supports an additional ``aliases`` argument, "
"which allows multiple strings to refer to the same subparser. This "
"example, like ``svn``, aliases ``co`` as a shorthand for ``checkout``::"
msgstr ""

#: ../../library/argparse.rst:1673
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers()\n"
">>> checkout = subparsers.add_parser('checkout', aliases=['co'])\n"
">>> checkout.add_argument('foo')\n"
">>> parser.parse_args(['co', 'bar'])\n"
"Namespace(foo='bar')"
msgstr ""

#: ../../library/argparse.rst:1680
msgid ""
"One particularly effective way of handling sub-commands is to combine the"
" use of the :meth:`add_subparsers` method with calls to "
":meth:`set_defaults` so that each subparser knows which Python function "
"it should execute.  For example::"
msgstr ""

#: ../../library/argparse.rst:1685
#, python-format
msgid ""
">>> # sub-command functions\n"
">>> def foo(args):\n"
"...     print(args.x * args.y)\n"
"...\n"
">>> def bar(args):\n"
"...     print('((%s))' % args.z)\n"
"...\n"
">>> # create the top-level parser\n"
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers()\n"
">>>\n"
">>> # create the parser for the \"foo\" command\n"
">>> parser_foo = subparsers.add_parser('foo')\n"
">>> parser_foo.add_argument('-x', type=int, default=1)\n"
">>> parser_foo.add_argument('y', type=float)\n"
">>> parser_foo.set_defaults(func=foo)\n"
">>>\n"
">>> # create the parser for the \"bar\" command\n"
">>> parser_bar = subparsers.add_parser('bar')\n"
">>> parser_bar.add_argument('z')\n"
">>> parser_bar.set_defaults(func=bar)\n"
">>>\n"
">>> # parse the args and call whatever function was selected\n"
">>> args = parser.parse_args('foo 1 -x 2'.split())\n"
">>> args.func(args)\n"
"2.0\n"
">>>\n"
">>> # parse the args and call whatever function was selected\n"
">>> args = parser.parse_args('bar XYZYX'.split())\n"
">>> args.func(args)\n"
"((XYZYX))"
msgstr ""

#: ../../library/argparse.rst:1717
msgid ""
"This way, you can let :meth:`parse_args` do the job of calling the "
"appropriate function after argument parsing is complete.  Associating "
"functions with actions like this is typically the easiest way to handle "
"the different actions for each of your subparsers.  However, if it is "
"necessary to check the name of the subparser that was invoked, the "
"``dest`` keyword argument to the :meth:`add_subparsers` call will work::"
msgstr ""

#: ../../library/argparse.rst:1724
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(dest='subparser_name')\n"
">>> subparser1 = subparsers.add_parser('1')\n"
">>> subparser1.add_argument('-x')\n"
">>> subparser2 = subparsers.add_parser('2')\n"
">>> subparser2.add_argument('y')\n"
">>> parser.parse_args(['2', 'frobble'])\n"
"Namespace(subparser_name='2', y='frobble')"
msgstr ""

#: ../../library/argparse.rst:1735
msgid "FileType objects"
msgstr ""

#: ../../library/argparse.rst:1739
msgid ""
"The :class:`FileType` factory creates objects that can be passed to the "
"type argument of :meth:`ArgumentParser.add_argument`.  Arguments that "
"have :class:`FileType` objects as their type will open command-line "
"arguments as files with the requested modes, buffer sizes, encodings and "
"error handling (see the :func:`open` function for more details)::"
msgstr ""

#: ../../library/argparse.rst:1745
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--raw', type=argparse.FileType('wb', 0))\n"
">>> parser.add_argument('out', type=argparse.FileType('w', "
"encoding='UTF-8'))\n"
">>> parser.parse_args(['--raw', 'raw.dat', 'file.txt'])\n"
"Namespace(out=<_io.TextIOWrapper name='file.txt' mode='w' "
"encoding='UTF-8'>, raw=<_io.FileIO name='raw.dat' mode='wb'>)"
msgstr ""

#: ../../library/argparse.rst:1751
msgid ""
"FileType objects understand the pseudo-argument ``'-'`` and automatically"
" convert this into ``sys.stdin`` for readable :class:`FileType` objects "
"and ``sys.stdout`` for writable :class:`FileType` objects::"
msgstr ""

#: ../../library/argparse.rst:1755
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('infile', type=argparse.FileType('r'))\n"
">>> parser.parse_args(['-'])\n"
"Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>)"
msgstr ""

#: ../../library/argparse.rst:1760
msgid "The *encodings* and *errors* keyword arguments."
msgstr ""

#: ../../library/argparse.rst:1765
msgid "Argument groups"
msgstr ""

#: ../../library/argparse.rst:1769
msgid ""
"By default, :class:`ArgumentParser` groups command-line arguments into "
"\"positional arguments\" and \"optional arguments\" when displaying help "
"messages. When there is a better conceptual grouping of arguments than "
"this default one, appropriate groups can be created using the "
":meth:`add_argument_group` method::"
msgstr ""

#: ../../library/argparse.rst:1775
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group = parser.add_argument_group('group')\n"
">>> group.add_argument('--foo', help='foo help')\n"
">>> group.add_argument('bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [--foo FOO] bar\n"
"\n"
"group:\n"
"  bar    bar help\n"
"  --foo FOO  foo help"
msgstr ""

#: ../../library/argparse.rst:1786
msgid ""
"The :meth:`add_argument_group` method returns an argument group object "
"which has an :meth:`~ArgumentParser.add_argument` method just like a "
"regular :class:`ArgumentParser`.  When an argument is added to the group,"
" the parser treats it just like a normal argument, but displays the "
"argument in a separate group for help messages.  The "
":meth:`add_argument_group` method accepts *title* and *description* "
"arguments which can be used to customize this display::"
msgstr ""

#: ../../library/argparse.rst:1794
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group1 = parser.add_argument_group('group1', 'group1 description')\n"
">>> group1.add_argument('foo', help='foo help')\n"
">>> group2 = parser.add_argument_group('group2', 'group2 description')\n"
">>> group2.add_argument('--bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [--bar BAR] foo\n"
"\n"
"group1:\n"
"  group1 description\n"
"\n"
"  foo    foo help\n"
"\n"
"group2:\n"
"  group2 description\n"
"\n"
"  --bar BAR  bar help"
msgstr ""

#: ../../library/argparse.rst:1812
msgid ""
"Note that any arguments not in your user-defined groups will end up back "
"in the usual \"positional arguments\" and \"optional arguments\" "
"sections."
msgstr ""

#: ../../library/argparse.rst:1817
msgid "Mutual exclusion"
msgstr ""

#: ../../library/argparse.rst:1821
msgid ""
"Create a mutually exclusive group. :mod:`argparse` will make sure that "
"only one of the arguments in the mutually exclusive group was present on "
"the command line::"
msgstr ""

#: ../../library/argparse.rst:1825
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group()\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(bar=True, foo=True)\n"
">>> parser.parse_args(['--bar'])\n"
"Namespace(bar=False, foo=False)\n"
">>> parser.parse_args(['--foo', '--bar'])\n"
"usage: PROG [-h] [--foo | --bar]\n"
"PROG: error: argument --bar: not allowed with argument --foo"
msgstr ""

#: ../../library/argparse.rst:1837
msgid ""
"The :meth:`add_mutually_exclusive_group` method also accepts a *required*"
" argument, to indicate that at least one of the mutually exclusive "
"arguments is required::"
msgstr ""

#: ../../library/argparse.rst:1841
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group(required=True)\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args([])\n"
"usage: PROG [-h] (--foo | --bar)\n"
"PROG: error: one of the arguments --foo --bar is required"
msgstr ""

#: ../../library/argparse.rst:1849
msgid ""
"Note that currently mutually exclusive argument groups do not support the"
" *title* and *description* arguments of "
":meth:`~ArgumentParser.add_argument_group`."
msgstr ""

#: ../../library/argparse.rst:1855
msgid "Parser defaults"
msgstr ""

#: ../../library/argparse.rst:1859
msgid ""
"Most of the time, the attributes of the object returned by "
":meth:`parse_args` will be fully determined by inspecting the command-"
"line arguments and the argument actions.  :meth:`set_defaults` allows "
"some additional attributes that are determined without any inspection of "
"the command line to be added::"
msgstr ""

#: ../../library/argparse.rst:1865
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', type=int)\n"
">>> parser.set_defaults(bar=42, baz='badger')\n"
">>> parser.parse_args(['736'])\n"
"Namespace(bar=42, baz='badger', foo=736)"
msgstr ""

#: ../../library/argparse.rst:1871
msgid "Note that parser-level defaults always override argument-level defaults::"
msgstr ""

#: ../../library/argparse.rst:1873
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='bar')\n"
">>> parser.set_defaults(foo='spam')\n"
">>> parser.parse_args([])\n"
"Namespace(foo='spam')"
msgstr ""

#: ../../library/argparse.rst:1879
msgid ""
"Parser-level defaults can be particularly useful when working with "
"multiple parsers.  See the :meth:`~ArgumentParser.add_subparsers` method "
"for an example of this type."
msgstr ""

#: ../../library/argparse.rst:1885
msgid ""
"Get the default value for a namespace attribute, as set by either "
":meth:`~ArgumentParser.add_argument` or by "
":meth:`~ArgumentParser.set_defaults`::"
msgstr ""

#: ../../library/argparse.rst:1889
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='badger')\n"
">>> parser.get_default('foo')\n"
"'badger'"
msgstr ""

#: ../../library/argparse.rst:1896
msgid "Printing help"
msgstr ""

#: ../../library/argparse.rst:1898
msgid ""
"In most typical applications, :meth:`~ArgumentParser.parse_args` will "
"take care of formatting and printing any usage or error messages.  "
"However, several formatting methods are available:"
msgstr ""

#: ../../library/argparse.rst:1904
msgid ""
"Print a brief description of how the :class:`ArgumentParser` should be "
"invoked on the command line.  If *file* is ``None``, :data:`sys.stdout` "
"is assumed."
msgstr ""

#: ../../library/argparse.rst:1910
msgid ""
"Print a help message, including the program usage and information about "
"the arguments registered with the :class:`ArgumentParser`.  If *file* is "
"``None``, :data:`sys.stdout` is assumed."
msgstr ""

#: ../../library/argparse.rst:1914
msgid ""
"There are also variants of these methods that simply return a string "
"instead of printing it:"
msgstr ""

#: ../../library/argparse.rst:1919
msgid ""
"Return a string containing a brief description of how the "
":class:`ArgumentParser` should be invoked on the command line."
msgstr ""

#: ../../library/argparse.rst:1924
msgid ""
"Return a string containing a help message, including the program usage "
"and information about the arguments registered with the "
":class:`ArgumentParser`."
msgstr ""

#: ../../library/argparse.rst:1929
msgid "Partial parsing"
msgstr ""

#: ../../library/argparse.rst:1933
msgid ""
"Sometimes a script may only parse a few of the command-line arguments, "
"passing the remaining arguments on to another script or program. In these"
" cases, the :meth:`~ArgumentParser.parse_known_args` method can be "
"useful.  It works much like :meth:`~ArgumentParser.parse_args` except "
"that it does not produce an error when extra arguments are present.  "
"Instead, it returns a two item tuple containing the populated namespace "
"and the list of remaining argument strings."
msgstr ""

#: ../../library/argparse.rst:1942
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam'])\n"
"(Namespace(bar='BAR', foo=True), ['--badger', 'spam'])"
msgstr ""

#: ../../library/argparse.rst:1949
msgid ""
":ref:`Prefix matching <prefix-matching>` rules apply to "
":meth:`parse_known_args`. The parser may consume an option even if it's "
"just a prefix of one of its known options, instead of leaving it in the "
"remaining arguments list."
msgstr ""

#: ../../library/argparse.rst:1956
msgid "Customizing file parsing"
msgstr ""

#: ../../library/argparse.rst:1960
msgid ""
"Arguments that are read from a file (see the *fromfile_prefix_chars* "
"keyword argument to the :class:`ArgumentParser` constructor) are read one"
" argument per line. :meth:`convert_arg_line_to_args` can be overridden "
"for fancier reading."
msgstr ""

#: ../../library/argparse.rst:1965
msgid ""
"This method takes a single argument *arg_line* which is a string read "
"from the argument file.  It returns a list of arguments parsed from this "
"string. The method is called once per line read from the argument file, "
"in order."
msgstr ""

#: ../../library/argparse.rst:1969
msgid ""
"A useful override of this method is one that treats each space-separated "
"word as an argument.  The following example demonstrates how to do this::"
msgstr ""

#: ../../library/argparse.rst:1972
msgid ""
"class MyArgumentParser(argparse.ArgumentParser):\n"
"    def convert_arg_line_to_args(self, arg_line):\n"
"        return arg_line.split()"
msgstr ""

#: ../../library/argparse.rst:1978
msgid "Exiting methods"
msgstr ""

#: ../../library/argparse.rst:1982
msgid ""
"This method terminates the program, exiting with the specified *status* "
"and, if given, it prints a *message* before that."
msgstr ""

#: ../../library/argparse.rst:1987
msgid ""
"This method prints a usage message including the *message* to the "
"standard error and terminates the program with a status code of 2."
msgstr ""

#: ../../library/argparse.rst:1993
msgid "Upgrading optparse code"
msgstr ""

#: ../../library/argparse.rst:1995
msgid ""
"Originally, the :mod:`argparse` module had attempted to maintain "
"compatibility with :mod:`optparse`.  However, :mod:`optparse` was "
"difficult to extend transparently, particularly with the changes required"
" to support the new ``nargs=`` specifiers and better usage messages.  "
"When most everything in :mod:`optparse` had either been copy-pasted over "
"or monkey-patched, it no longer seemed practical to try to maintain the "
"backwards compatibility."
msgstr ""

#: ../../library/argparse.rst:2002
msgid ""
"The :mod:`argparse` module improves on the standard library "
":mod:`optparse` module in a number of ways including:"
msgstr ""

#: ../../library/argparse.rst:2005
msgid "Handling positional arguments."
msgstr ""

#: ../../library/argparse.rst:2006
msgid "Supporting sub-commands."
msgstr ""

#: ../../library/argparse.rst:2007
msgid "Allowing alternative option prefixes like ``+`` and ``/``."
msgstr ""

#: ../../library/argparse.rst:2008
msgid "Handling zero-or-more and one-or-more style arguments."
msgstr ""

#: ../../library/argparse.rst:2009
msgid "Producing more informative usage messages."
msgstr ""

#: ../../library/argparse.rst:2010
msgid "Providing a much simpler interface for custom ``type`` and ``action``."
msgstr ""

#: ../../library/argparse.rst:2012
msgid "A partial upgrade path from :mod:`optparse` to :mod:`argparse`:"
msgstr ""

#: ../../library/argparse.rst:2014
msgid ""
"Replace all :meth:`optparse.OptionParser.add_option` calls with "
":meth:`ArgumentParser.add_argument` calls."
msgstr ""

#: ../../library/argparse.rst:2017
msgid ""
"Replace ``(options, args) = parser.parse_args()`` with ``args = "
"parser.parse_args()`` and add additional "
":meth:`ArgumentParser.add_argument` calls for the positional arguments. "
"Keep in mind that what was previously called ``options``, now in the "
":mod:`argparse` context is called ``args``."
msgstr ""

#: ../../library/argparse.rst:2022
msgid ""
"Replace :meth:`optparse.OptionParser.disable_interspersed_args` by "
"setting ``nargs`` of a positional argument to `argparse.REMAINDER`_, or "
"use :meth:`~ArgumentParser.parse_known_args` to collect unparsed argument"
" strings in a separate list."
msgstr ""

#: ../../library/argparse.rst:2027
msgid ""
"Replace callback actions and the ``callback_*`` keyword arguments with "
"``type`` or ``action`` arguments."
msgstr ""

#: ../../library/argparse.rst:2030
msgid ""
"Replace string names for ``type`` keyword arguments with the "
"corresponding type objects (e.g. int, float, complex, etc)."
msgstr ""

#: ../../library/argparse.rst:2033
msgid ""
"Replace :class:`optparse.Values` with :class:`Namespace` and "
":exc:`optparse.OptionError` and :exc:`optparse.OptionValueError` with "
":exc:`ArgumentError`."
msgstr ""

#: ../../library/argparse.rst:2037
#, python-format
msgid ""
"Replace strings with implicit arguments such as ``%default`` or ``%prog``"
" with the standard Python syntax to use dictionaries to format strings, "
"that is, ``%(default)s`` and ``%(prog)s``."
msgstr ""

#: ../../library/argparse.rst:2041
msgid ""
"Replace the OptionParser constructor ``version`` argument with a call to "
"``parser.add_argument('--version', action='version', version='<the "
"version>')``."
msgstr ""

